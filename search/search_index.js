var __index = Promise.resolve({"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"<p>Rarible Multichain Protocol is a blockchain-agnostic and decentralized tool to query, issue, and trade NFTs.</p>","title":"Rarible Protocol"},{"location":"#learn-more-about-protocol-usage","text":"<p>Protocol Overview</p> <p>Features List</p> <p>Status Page</p>","title":"Learn more about Protocol usage"},{"location":"#explore-references-and-resources","text":"<p>API Reference</p> <p>Multichain SDK</p>","title":"Explore references and resources"},{"location":"#get-started-with-multichain-sdk-basics-and-create-the-first-application","text":"<p>Quick Start</p> <p>React Example App</p>","title":"Get started with Multichain SDK basics and create the first application"},{"location":"#take-community-support-and-additional-information","text":"<p>Community and resources</p>","title":"Take community support and additional information"},{"location":"LICENSE/","text":"<pre><code>                GNU GENERAL PUBLIC LICENSE\n                   Version 3, 29 June 2007\n</code></pre> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/  Everyone is permitted to copy and distribute verbatim copies  of this license document, but changing it is not allowed.</p> <pre><code>                        Preamble\n</code></pre> <p>The GNU General Public License is a free, copyleft license for software and other kinds of works.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works.  By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.  We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors.  You can apply it to your programs, too.</p> <p>When we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights.  Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.</p> <p>For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received.  You must make sure that they, too, receive or can get the source code.  And you must show them these terms so they know their rights.</p> <p>Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.</p> <p>For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software.  For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.</p> <p>Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so.  This is fundamentally incompatible with the aim of protecting users' freedom to change the software.  The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable.  Therefore, we have designed this version of the GPL to prohibit the practice for those products.  If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.</p> <p>Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary.  To prevent this, the GPL assures that patents cannot be used to render the program non-free.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p> <pre><code>                   TERMS AND CONDITIONS\n</code></pre> <ol> <li>Definitions.</li> </ol> <p>\"This License\" refers to version 3 of the GNU General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License.  Each licensee is addressed as \"you\".  \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy.  The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy.  Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies.  Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License.  If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p> <ol> <li>Source Code.</li> </ol> <p>The \"source code\" for a work means the preferred form of the work for making modifications to it.  \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form.  A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities.  However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work.  For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p> <ol> <li>Basic Permissions.</li> </ol> <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met.  This License explicitly affirms your unlimited permission to run the unmodified Program.  The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work.  This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force.  You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright.  Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below.  Sublicensing is not allowed; section 10 makes it unnecessary.</p> <ol> <li>Protecting Users' Legal Rights From Anti-Circumvention Law.</li> </ol> <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p> <ol> <li>Conveying Verbatim Copies.</li> </ol> <p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p> <ol> <li>Conveying Modified Source Versions.</li> </ol> <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <pre><code>a) The work must carry prominent notices stating that you modified\nit, and giving a relevant date.\n\nb) The work must carry prominent notices stating that it is\nreleased under this License and any conditions added under section\n7.  This requirement modifies the requirement in section 4 to\n\"keep intact all notices\".\n\nc) You must license the entire work, as a whole, under this\nLicense to anyone who comes into possession of a copy.  This\nLicense will therefore apply, along with any applicable section 7\nadditional terms, to the whole of the work, and all its parts,\nregardless of how they are packaged.  This License gives no\npermission to license the work in any other way, but it does not\ninvalidate such permission if you have separately received it.\n\nd) If the work has interactive user interfaces, each must display\nAppropriate Legal Notices; however, if the Program has interactive\ninterfaces that do not display Appropriate Legal Notices, your\nwork need not make them do so.\n</code></pre> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit.  Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p> <ol> <li>Conveying Non-Source Forms.</li> </ol> <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <pre><code>a) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by the\nCorresponding Source fixed on a durable physical medium\ncustomarily used for software interchange.\n\nb) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by a\nwritten offer, valid for at least three years and valid for as\nlong as you offer spare parts or customer support for that product\nmodel, to give anyone who possesses the object code either (1) a\ncopy of the Corresponding Source for all the software in the\nproduct that is covered by this License, on a durable physical\nmedium customarily used for software interchange, for a price no\nmore than your reasonable cost of physically performing this\nconveying of source, or (2) access to copy the\nCorresponding Source from a network server at no charge.\n\nc) Convey individual copies of the object code with a copy of the\nwritten offer to provide the Corresponding Source.  This\nalternative is allowed only occasionally and noncommercially, and\nonly if you received the object code with such an offer, in accord\nwith subsection 6b.\n\nd) Convey the object code by offering access from a designated\nplace (gratis or for a charge), and offer equivalent access to the\nCorresponding Source in the same way through the same place at no\nfurther charge.  You need not require recipients to copy the\nCorresponding Source along with the object code.  If the place to\ncopy the object code is a network server, the Corresponding Source\nmay be on a different server (operated by you or a third party)\nthat supports equivalent copying facilities, provided you maintain\nclear directions next to the object code saying where to find the\nCorresponding Source.  Regardless of what server hosts the\nCorresponding Source, you remain obligated to ensure that it is\navailable for as long as needed to satisfy these requirements.\n\ne) Convey the object code using peer-to-peer transmission, provided\nyou inform other peers where the object code and Corresponding\nSource of the work are being offered to the general public at no\ncharge under subsection 6d.\n</code></pre> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling.  In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage.  For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product.  A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source.  The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information.  But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed.  Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p> <ol> <li>Additional Terms.</li> </ol> <p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law.  If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it.  (Additional permissions may be written to require their own removal in certain cases when you modify the work.)  You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <pre><code>a) Disclaiming warranty or limiting liability differently from the\nterms of sections 15 and 16 of this License; or\n\nb) Requiring preservation of specified reasonable legal notices or\nauthor attributions in that material or in the Appropriate Legal\nNotices displayed by works containing it; or\n\nc) Prohibiting misrepresentation of the origin of that material, or\nrequiring that modified versions of such material be marked in\nreasonable ways as different from the original version; or\n\nd) Limiting the use for publicity purposes of names of licensors or\nauthors of the material; or\n\ne) Declining to grant rights under trademark law for use of some\ntrade names, trademarks, or service marks; or\n\nf) Requiring indemnification of licensors and authors of that\nmaterial by anyone who conveys the material (or modified versions of\nit) with contractual assumptions of liability to the recipient, for\nany liability that these contractual assumptions directly impose on\nthose licensors and authors.\n</code></pre> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10.  If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term.  If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p> <ol> <li>Termination.</li> </ol> <p>You may not propagate or modify a covered work except as expressly provided under this License.  Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License.  If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p> <ol> <li>Acceptance Not Required for Having Copies.</li> </ol> <p>You are not required to accept this License in order to receive or run a copy of the Program.  Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance.  However, nothing other than this License grants you permission to propagate or modify any covered work.  These actions infringe copyright if you do not accept this License.  Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p> <ol> <li>Automatic Licensing of Downstream Recipients.</li> </ol> <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License.  You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations.  If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License.  For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p> <ol> <li>Patents.</li> </ol> <p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based.  The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version.  For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement).  To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients.  \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License.  You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p> <ol> <li>No Surrender of Others' Freedom.</li> </ol> <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all.  For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p> <ol> <li>Use with the GNU Affero General Public License.</li> </ol> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work.  The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.</p> <ol> <li>Revised Versions of this License.</li> </ol> <p>The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number.  If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions.  However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p> <ol> <li>Disclaimer of Warranty.</li> </ol> <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> <ol> <li>Limitation of Liability.</li> </ol> <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p> <ol> <li>Interpretation of Sections 15 and 16.</li> </ol> <p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <pre><code>                 END OF TERMS AND CONDITIONS\n\n        How to Apply These Terms to Your New Programs\n</code></pre> <p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program.  It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>&lt;one line to give the program's name and a brief idea of what it does.&gt;\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:</p> <pre><code>&lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n</code></pre> <p>The hypothetical commands <code>show w' and</code>show c' should show the appropriate parts of the General Public License.  Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\".</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/.</p> <p>The GNU General Public License does not permit incorporating your program into proprietary programs.  If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library.  If this is what you want to do, use the GNU Lesser General Public License instead of this License.  But first, please read https://www.gnu.org/licenses/why-not-lgpl.html.</p>","title":"LICENSE"},{"location":"MIT-LICENSE/","text":"<p>Copyright (c) 2021, Rarible DAO</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>","title":"MIT LICENSE"},{"location":"api-reference/","text":"<p>Use these base URLs to access our API on different networks.</p> <p><code>api.rarible.org</code> or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs.</p>    Base URL Network     https://api.rarible.org/v0.1 Production (Mainnet)   https://api-staging.rarible.org/v0.1 Staging (Rinkeby, Mumbai)   https://api-dev.rarible.org/v0.1 Development (Ropsten, Mumbai, Hangzhou)   https://api-e2e.rarible.org/v0.1 e2e    <p>Protocol API documentation can be found here:</p> <ul> <li>Mainnet</li> <li>Staging</li> <li>Development</li> <li>e2e testing</li> </ul> <p>The API interacts with different blockchain networks for different environments.</p> <p>Production environments:</p> <ul> <li>Ethereum: mainnet</li> <li>Tezos: mainnet</li> <li>Flow: mainnet</li> <li>Polygon: mainnet</li> </ul> <p>Staging environments:</p> <ul> <li>Ethereum: rinkeby</li> <li>Flow: devnet</li> <li>Polygon: mumbai</li> </ul> <p>Development environments:</p> <ul> <li>Ethereum: ropsten</li> <li>Tezos: hangzhou</li> <li>Flow: devnet</li> <li>Polygon: mumbai</li> </ul>","title":"API Reference"},{"location":"api-reference/#usage-with-sdk","text":"<p>API is pretty easy when it comes to SDK, you can use it with SDK like this:</p> <pre><code>const response = await sdk.apis.order. (function you want to invoke)\n</code></pre> <p>The most important thing is to remember that there are different endpoints for different environments when it comes to the API.</p> <p>While changing environments, you would need to change endpoints accordingly because different APIs function in other chains. E.g., there're different endpoints for Rinkeby than for Ropsten. SDK is taking full care of managing that.</p>","title":"Usage with SDK"},{"location":"faq/","text":"<p>See Discussion QA section on our GitHub repo, Discord, and documentation for more answers.</p> <p>If you haven't found an answer to your question, you can create a new discussion here. </p> <p>WIP. It's the first FAQ version.</p>","title":"Frequently Asked Questions"},{"location":"faq/#do-i-need-tokenid-to-lazy-minting-nft-through-sdk","text":"<p>Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint.</p>","title":"Do I need tokenId to lazy minting NFT through SDK?"},{"location":"faq/#how-to-connect-metamask-with-sdk","text":"<p>Something like that:</p> <pre><code>new EthereumWallet(new Web3Ethereum({ web3: web31 }))\n</code></pre> <p>Now you can pass your wallet to the create SDK factory.</p> <p>See Rarible Protocol SDK for more information about using SDK.</p>","title":"How to connect Metamask with SDK?"},{"location":"faq/#why-the-price-in-the-sell-order-cant-be-updated-to-a-higher-value","text":"<p>That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract.</p> <p>So, to make the price higher, you should cancel the order and sign a new message.</p>","title":"Why the price in the sell order can't be updated to a higher value?"},{"location":"faq/#what-does-the-union-service-repo-do","text":"<p>Multichain service also known as <code>union service</code> is a layer that connects different Blockchain APIs. It sits on top of all of them.</p>","title":"What does the union-service repo do?"},{"location":"faq/#what-kind-of-fee-model-does-the-protocol-use","text":"<p>See Smart contracts for Rarible protocol repo on GitHub for more information about fees.</p> <p>Also, you can find more information about fees in Rarible Protocol Ethereum docs.</p>","title":"What kind of fee model does the protocol use?"},{"location":"faq/#what-is-deploy-in-the-sdk-used-for","text":"<p>It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.</p>","title":"What is \"deploy\" in the SDK used for?"},{"location":"features/","text":"Ethereum Flow Tezos Polygon Solana(coming soon)     Multichain Protocol supported features        NFTs types ERC-721, ERC-1155 Flow NFT standart FA2 (TZIP-012) ERC-721, ERC-1155    Buy now        Sell NFTs        Bids   2022 Q2     Create, update and cancel orders        Create NFT collection        Mint NFTs        Lazy mint NFTs        Transfer NFTs        Burn NFTs        Fees and Royalties        On-chain Auction 2022 Q1 2022 Q1 2022 Q2 2022 Q1            Seaching/Data retrieval features        Search tokens by parameters        Search blockchain events        Search orders by parameters        Create or update orders        Get collections information                IndexerCore service to retrieve data from blockchain        Fetch NFTs from blockchain        Fetch Orders from blockchain        Fetch fungible tokens from blockchain   2022 Q1     Fetch balances        Listing from marketplaces other from Rarible                Additional NFT collections        CryptoPunks","title":"Rarible Protocol Features List"},{"location":"union-sdk/","text":"","title":"Rarible Protocol SDK"},{"location":"union-sdk/#overview","text":"<p>Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets (ERC721, ERC1155) and list them to sell, trade, etc.</p> <p>In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box.</p> <p>Currently, Rarible Protocol SDK supports following blockchains:</p> <ul> <li>Ethereum (mainnet, ropsten, rinkeby)</li> <li>Flow (mainnet, ropsten, rinkeby)</li> <li>Tezos (mainnet, granada)</li> <li>Polygon (mainnet, mumbai)</li> </ul>","title":"Overview"},{"location":"union-sdk/#installation","text":"<p>Using SDK should be fast, easy and intuitive \u2014 that's for what we're aiming for. Below you can see an example of implementation.</p> <ol> <li> <p>Install required packages using npm or yarn.</p> <p>For most of the projects, apart of the Rarible SDK we'll also need web3.</p> <pre><code>npm install -D @rarible/sdk\nnpm install web3\n</code></pre> <p>or using yarn</p> <pre><code>yarn add @rarible/sdk -D\nyarn add web3\n</code></pre> </li> <li> <p>Create a project with the JS framework of your choice (we'll be using NextJS here).</p> </li> </ol> <p>In order to properly set up the Rarible SDK we need to follow some standard web3 practices.</p> <ol> <li>Grab ethereum object out of the global window object.</li> <li>Use it to create a new instance of Web3.</li> <li>Create new instance of EthereumWallet class.</li> <li>Create Rarible SDK with a new instance of ethereumWallet, created in previous step.</li> </ol> <p>In code, it looks like that (using TypeScript):</p> <pre><code>// Imports\nimport Web3 from \"web3\"\nimport { createRaribleSdk } from \"@rarible/sdk\"\nimport { EthereumWallet } from \"@rarible/sdk-wallet\"\nimport { Blockchain } from \"@rarible/api-client\"\nimport { Web3Ethereum } from \"@rarible/web3-ethereum\"\n\n// Code\nconst { ethereum } = window as any\nconst web3 = new Web3(provider)\nconst web3Ethereum = new Web3Ethereum({ web3 })\nconst ethWallet = new EthereumWallet(web3Ethereum)\nconst raribleSdk = createRaribleSdk(ethWallet, \"staging\")\n</code></pre> <p><code>RaribleSdk</code> object is ready for use.</p> <p>Few more things:</p> <ol> <li> <p>If you're wondering what's \"staging\" in <code>createRaribleSdk</code> it's environment parameter. We have four options here:</p> <ul> <li><code>prod</code> (mainnet)</li> <li><code>dev</code> (ropsten)</li> <li><code>staging</code> (rinkeby)</li> <li><code>e2e</code> (you probably won't use this)</li> </ul> <p>The difference between them is the chain Id and the Rarible API endpoint.</p> </li> <li> <p>If you're creating any sort of blockchain application which will interact with users you'll still need to implement connect metamask button in order to get their wallet connected.</p> </li> </ol>","title":"Installation"},{"location":"union-sdk/#metamask-integration-with-rarible","text":"<p>In the previous chapter we talked about how we can initalize Rarible SDK, but it was more theoretical. In actual development, in almost any dApp we'd like to identify users through a wallet address they are using.</p> <p>At first sight you may think that it's not really related to the Rarible Protocol, but a correct set up is required to use the SDK smoothly and easily.</p> <p>In this chapter, I will guide you through this process (it's a proposition of implementation, not the only correct way, but widely used). Once you get the idea you can work with that however you'd like.</p> <p>Below you can find a list of steps that should be taken after the \"Connect Metamask\" button is clicked.</p> <ol> <li> <p>Identify if user has a blockchain provider (i.e. if he has Metamask installed)</p> <pre><code>const getProvider = () =&gt; {\n  // 1. Getting ethereum object out of global JS object\n  if ((window as any).ethereum) {\n    const { ethereum } = window as any;\n\n    return ethereum;\n  }\n  // 2. If ethereum property does not exist it means that user needs to install Metamask\n  else {\n    alert(\"Please install Metamask\");\n  }\n};\n\nconst provider = getProvider();\n</code></pre> </li> <li> <p>Request and get metamask accounts - metamask should pop up in this step, to authorize the app</p> <pre><code>const connect = async () =&gt; {\n  if (!provider) {\n    alert(\"No provider found!\");\n  } else {\n    // 1. Making metamask request\n    await provider.request({ method: \"eth_requestAccounts\" });\n    // 2. Getting currently connected accounts\n    const accounts = await provider.request({ method: \"eth_accounts\" });\n\n    if (accounts.length &gt; 0) {\n      // First item is always currently used account\n      setAccount(accounts[0]);\n    }\n    // Setting event listener on whenever user has changed account\n    provider.on(\"accountsChanged\", (accs: any) =&gt; {\n      const [currentAccount] = accs;\n      setAccount(currentAccount);\n    });\n  }\n};\n</code></pre> </li> <li> <p>Prepare EthereumWallet for RaribleSdk</p> <pre><code>const wallet = () =&gt; {\n  // 1. Check if provider and currentAccount is successfully set\n  if (provider &amp;&amp; currentAccount) {\n    return new EthereumWallet(\n      new Web3Ethereum({ web3: new Web3(provider), from: currentAccount })\n    );\n  } else {\n    return undefined;\n  }\n};\n</code></pre> </li> <li> <p>Create RaribleSDK</p> <pre><code>// 1. \"env\" parameter is one of \"prod\" | \"dev\" | \"staging\" | \"e2e\" mentioned earlier\nconst sdk = (env: string) =&gt; {\n  if (wallet) {\n    return createRaribleSdk(wallet, env as any);\n  } else {\n    return undefined;\n  }\n};\n</code></pre> </li> </ol>","title":"Metamask integration with Rarible"},{"location":"union-sdk/#usage-sdk-on-the-server-backend","text":"<p>The SDK was designed for use on the frontend side. To use the SDK on the server side (backend):</p> <ol> <li> <p>Install packages:</p> <pre><code>yarn add tslib@2.3.1\nyarn add form-data\nyarn add node-fetch\n</code></pre> </li> <li> <p>Add dependencies:</p> <pre><code>global.FormData = require(\"form-data\")\nglobal.window = {\n  fetch: require(\"node-fetch\"),\n  dispatchEvent: () =&gt; {\n  },\n}\nglobal.CustomEvent = function CustomEvent() {\n  return\n}\n</code></pre> </li> </ol> <p>Now we have the working example with Metamask connected and Rarible SDK configured.</p> <p>Here you can find code used in example in broader picture.</p> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>","title":"Usage SDK on the server (backend)"},{"location":"ethereum/contract-addresses/","text":"<p>Here you can find Rarible Smart Contracts deployed instances across Ethereum Ropsten Testnet, Rinkeby Testnet and Mainnet.</p>","title":"Contract Addresses"},{"location":"ethereum/contract-addresses/#mainnet","text":"<ul> <li>Asset Contract ERC721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C\u2197</li> <li>Asset Contract ERC1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 \u2197</li> <li>Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 \u2197</li> <li>External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD \u2197</li> <li>NFT Transfer Proxy (for Approvals) 0x4fee7b061c97c9c496b01dbce9cdb10c02f0a0be \u2197</li> <li>ERC721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 \u2197</li> <li>ERC1155 Token Factory 0xDA5BFe0bD4443d63833C8f4E3284357299eaE6BC \u2197</li> </ul>","title":"Mainnet"},{"location":"ethereum/contract-addresses/#rinkeby","text":"<p>Is known to usually be more reliable than Ropsten.</p> <ul> <li>Asset Contract ERC721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\u2197</li> <li>Asset Contract ERC1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 \u2197</li> <li>Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b \u2197</li> <li>External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 \u2197</li> <li>NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 \u2197</li> <li>ERC721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf \u2197</li> <li>ERC1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d \u2197</li> </ul>","title":"Rinkeby"},{"location":"ethereum/contract-addresses/#ropsten","text":"<p>Is known to be less reliable.</p> <ul> <li>Asset Contract ERC721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\u2197</li> <li>Asset Contract ERC1155 0x6a94aC200342AC823F909F142a65232E2f052183 \u2197</li> <li>Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD \u2197</li> <li>External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B \u2197</li> <li>NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 \u2197</li> <li>ERC721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 \u2197</li> <li>ERC1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e \u2197</li> </ul>","title":"Ropsten"},{"location":"ethereum/ethereum-overview/","text":"","title":"Rarible Protocol Ethereum"},{"location":"ethereum/ethereum-overview/#overview","text":"<p>Rarible Protocol Ethereum is a set of tools to query, issue, and trade NFTs in the Ethereum blockchain network. It consists of Smart Contracts, Indexer, API, and SDK.</p> <p></p> <p>Main features:</p> <ul> <li>Decentralized Exchange</li> <li>Open Source Indexer</li> <li>Minting single (ERC-721) and multiple (ERC-1155) tokens, including lazy minting</li> <li>Ability to share Fees</li> <li>Royalties Support</li> <li>Public Order Book</li> </ul>","title":"Overview"},{"location":"ethereum/ethereum-overview/#smart-contracts","text":"<p>Rarible Smart Contracts for Ethereum are stored on the Ethereum blockchain. They will run when predetermined conditions are met.</p> <p>To see more details about the smart contracts as well as their code, check the Smart Contracts page or the Protocol Contracts github repo.</p>","title":"Smart Contracts"},{"location":"ethereum/ethereum-overview/#api-reference","text":"<p>Subject to change</p> <p>The following APIs are used for internal work and can change in future versions.</p>  <p>Use these base URLs to access API on different Ethereum networks:</p>    Base URL Network Chain ID     https://ethereum-api.rarible.org/v0.1 Mainnet 1   https://ethereum-api-staging.rarible.org/v0.1 Rinkeby 4   https://ethereum-api-dev.rarible.org/v0.1 Ropsten 3   https://ethereum-api-e2e.rarible.org/v0.1 - -    <p>Ethereum API documentation can be found here:</p> <ul> <li>Mainnet</li> <li>Staging</li> <li>Development</li> <li>e2e testing</li> </ul> <p>See the page API and Indexer to see how to work with the API.</p> <p>For more information, see Ethereum Indexer and Ethereum OpenAPI repos on GitHub.</p>","title":"API Reference"},{"location":"ethereum/ethereum-overview/#sdk","text":"<p>Rarible Protocol Ethereum SDK can help interact with your application and the Rarible protocol.</p> <p>Main features:</p> <ul> <li>Create Mint and Lazy Minting ERC-721 and ERC-1155 tokens</li> <li>Create Sell Orders</li> <li>Create and accept Bid</li> <li>Buy tokens</li> <li>Transfer tokens</li> <li>Burn tokens</li> </ul> <p>For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.</p>","title":"SDK"},{"location":"ethereum/api/create-lazy-minting/","text":"<p>To mint an NFT using Lazy Minting, use the mintNftAsset method in nft-lazy-mint-controller.</p>","title":"Using Lazy Minting"},{"location":"ethereum/api/create-lazy-minting/#mintnftasset","text":"<p>Creates a Lazy Minted NFT token.</p> <p><code>https://ethereum-api-staging.rarible.org/v0.1/nft/mints</code></p> <p>Example request (staging):</p> <pre><code>curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/nft/mints' \\\n  --header 'content-type: application/json' \\\n  --data-raw '{\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"@type\":\"ERC721\",\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"]}'\n</code></pre> <p>Request parameters:</p> <ul> <li>@typerequired \u2014 token type <code>ERC721</code> or <code>ERC1155</code></li> <li>supply \u2014 the total number of tokens for Mint. Only for ERC-1155</li> <li>contract \u2014 address of the smart contract</li> <li>tokenId \u2014 token ID</li> <li>uri \u2014 suffix for the token URI. The prefix is usually <code>ipfs:/</code></li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of digital signatures. Each creator must have a signature the only exception being when the creator sends a mint transaction.</li> </ul> <p>Response example (status 200):</p> <pre><code>{\n  \"id\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:83144199935168800027256855471009236590928205711995533202494108027144764391425\",\n  \"contract\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n  \"tokenId\": \"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\n  \"creators\": [\n    {\n      \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n      \"value\": 10000\n    }\n  ],\n  \"supply\": \"1\",\n  \"lazySupply\": \"1\",\n  \"owners\": [\n    \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\"\n  ],\n  \"royalties\": [\n    {\n      \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n      \"value\": 1000\n    }\n  ],\n  \"date\": \"2021-11-23T15:37:03.610Z\",\n  \"pending\": [],\n  \"deleted\": false,\n  \"meta\": {\n    \"name\": \"Violence Token\",\n    \"description\": \"\",\n    \"attributes\": [],\n    \"image\": {\n      \"url\": {\n        \"ORIGINAL\": \"ipfs://ipfs/QmbnW9qS5dcmXavo55yqzmF79wWT6qTcYKBAAaS3gDgrDa/image.jpeg\"\n      },\n      \"meta\": {\n        \"ORIGINAL\": {\n          \"type\": \"image/jpeg\",\n          \"width\": 400,\n          \"height\": 400\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>id \u2014 item ID, has the format <code>${contract}:${tokenId}</code></li> <li>contract \u2014 address of the smart contract</li> <li>tokenId \u2014 token ID</li> <li>creators \u2014 array of information about creators</li> <li>supply \u2014 number of tokens created</li> <li>lazysupply \u2014 the number of Lazy Minting tokens created</li> <li>owners \u2014 array of information about token owners</li> <li>royalties \u2014 an array of information about royalties</li> <li>date \u2014 date of token creation</li> <li>pending \u2014 whether the item is incomplete. For example, it is in the status <code>TRANSFER</code></li> <li>deleted \u2014 is the order deleted</li> <li>meta \u2014 meta information about the item</li> </ul>","title":"mintNftAsset"},{"location":"ethereum/api/create-orders/","text":"<p>To create an order, use the upsertOrder method in order-controller.</p>","title":"Create Orders"},{"location":"ethereum/api/create-orders/#upsertorder","text":"<p>Creates or updates an Order.</p> <p><code>https://ethereum-api.rarible.org/v0.1/order/orders</code></p> <p>Example request (staging):</p> <pre><code>curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/order/orders' \\\n  --header 'content-type: application/json' \\\n  --data-raw '{\"maker\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"type\":\"RARIBLE_V2\",\"data\":{\"dataType\":\"RARIBLE_V2_DATA_V1\",\"payouts\":[],\"originFees\":[{\"account\":\"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\"value\":250}]},\"salt\":\"86881339267547208763979074509610437060593762063071194041427040496432360352297\",\"signature\":\"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\"make\":{\"assetType\":{\"@type\":\"ERC721\",\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"],\"assetClass\":\"ERC721_LAZY\"},\"value\":\"1\"},\"take\":{\"assetType\":{\"assetClass\":\"ETH\"},\"value\":\"10000000000000000\"}}'\n</code></pre> <p>Request parameters:</p> <ul> <li>type \u2014 order type <code>RARIBLE_V1</code> or <code>RARIBLE_V2</code></li> <li>data \u2014 data for creating or updating the order. The required fields depend on order type</li> <li>maker \u2014 address of the order creator</li> <li>taker \u2014 address of the recipient of the order (optional)</li> <li>make \u2014 make the side of the order. What the creator has</li> <li>take \u2014 take the side of the order. What the creator wants to get in exchange for the make side</li> <li>salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash</li> <li>start \u2014 the start date of the order placement, from which the buyer can make a Bid (optional) p.s. unix time is used </li> <li>end \u2014 the end date of the order placement, before which the buyer can make a Bid (optional) p.s. unix time is used </li> <li>signature \u2014 the digital signature of the order creator</li> </ul> <p>Response example (status 200):</p> <pre><code>{\n  \"type\": \"RARIBLE_V2\",\n  \"maker\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n  \"make\": {\n    \"assetType\": {\n      \"assetClass\": \"ERC721_LAZY\",\n      \"contract\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n      \"tokenId\": \"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\n      \"uri\": \"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\n      \"creators\": [\n        {\n          \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n          \"value\": 10000\n        }\n      ],\n      \"royalties\": [\n        {\n          \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n          \"value\": 1000\n        }\n      ],\n      \"signatures\": [\n        \"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"\n      ]\n    },\n    \"value\": \"1\",\n    \"valueDecimal\": 1\n  },\n  \"take\": {\n    \"assetType\": {\n      \"assetClass\": \"ETH\"\n    },\n    \"value\": \"10000000000000000\",\n    \"valueDecimal\": 0.01\n  },\n  \"fill\": \"0\",\n  \"fillValue\": 0,\n  \"makeStock\": \"1\",\n  \"makeStockValue\": 1,\n  \"cancelled\": false,\n  \"salt\": \"0xc015186be955e586fb9d3bc1ddbbf43470a40d18b4ccdc750af405155eee6a29\",\n  \"signature\": \"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\n  \"createdAt\": \"2021-11-23T15:37:13.158Z\",\n  \"lastUpdateAt\": \"2021-11-23T15:37:13.158Z\",\n  \"pending\": [],\n  \"hash\": \"0x279863b844f7bae2db201bff5abd9467f380eb029399e1339671d9d51f9a0280\",\n  \"makeBalance\": \"0\",\n  \"makePrice\": 0.01,\n  \"makePriceUsd\": 40.193574609729986,\n  \"priceHistory\": [\n    {\n      \"date\": \"2021-11-23T15:37:13.158Z\",\n      \"makeValue\": 1,\n      \"takeValue\": 0.01\n    }\n  ],\n  \"status\": \"ACTIVE\",\n  \"data\": {\n    \"dataType\": \"RARIBLE_V2_DATA_V1\",\n    \"payouts\": [],\n    \"originFees\": [\n      {\n        \"account\": \"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\n        \"value\": 250\n      }\n    ]\n  }\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>type \u2014 order type <code>RARIBLE_V1</code>, <code>RARIBLE_V2</code>, <code>OPEN_SEA_V1</code> or <code>CRYPTO_PUNK</code></li> <li>data \u2014 information about order type, Fees, etc.</li> <li>maker \u2014 address of the order creator</li> <li>taker \u2014 address of the recipient of the order</li> <li>make \u2014 make the order side. What the creator has</li> <li>take \u2014 take the side of the order. What the creator wants to get in exchange for the make side</li> <li>fill \u2014 filling in data when matching</li> <li>fillvalue \u2014 data filling value</li> <li>start \u2014 the starting date of the order placement, from which the buyer can make a Bid</li> <li>end \u2014 the end date of the order placement before which the buyer can make a Bid</li> <li>makestock \u2014 how much is available for sale</li> <li>makestockvalue \u2014 the value of how much is available for sale</li> <li>cancelled \u2014 the order is canceled or not</li> <li>salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash</li> <li>signature \u2014 digital signature of the order creator</li> <li>createdAt \u2014 date of order creation</li> <li>lastupdateat \u2014 order update date</li> <li>pending \u2014 whether the order is incomplete. For example, it is in the status of <code>CANCEL</code>, <code>ORDER_SIDE_MATCH</code> or <code>ON_CHAIN_ORDER</code></li> <li>hash \u2014 hash of the order</li> <li>makebalance \u2014 balance of the order creator</li> <li>makeprice \u2014 order price</li> <li>Takeprice \u2014 buyer's suggested price</li> <li>makepriceusd \u2014 order price in USD</li> <li>takepriceusd \u2014 price in USD suggested by the buyer</li> <li>pricehistory \u2014 history of price changes</li> <li>status \u2014 order status <code>ACTIVE</code>, <code>FILLED</code>, <code>HISTORICAL</code>, <code>INACTIVE</code> or <code>CANCELLED</code></li> </ul>","title":"upsertOrder"},{"location":"ethereum/api/ethereum-api-indexer/","text":"<p>The main functions of the API and indexer are:</p> <ul> <li>Follow the blockchain</li> <li>Handle read requests</li> <li>Process creation requests</li> </ul>","title":"API and Indexer Overview"},{"location":"ethereum/api/ethereum-api-indexer/#architecture","text":"<p>The Rarible Protocol Ethereum indexer consists of the following parts:</p> <ul> <li>NFT indexer \u2014 aggregates NFTs data</li> <li>ERC-20 indexer \u2014 aggregates data about ERC-20 tokens and balances</li> <li>Order indexer \u2014 aggregates Orders data from different platforms</li> </ul> <p>Each indexer listens to a specific part of the Ethereum blockchain. The indexers can be used to request data about the state of the blockchain.</p> <p>Indexers generate events when the state changes. They are developed with Spring Framework and use these external services:</p> <ul> <li>MongoDB \u2014 main data storage</li> <li>Apache Kafka \u2014 event handling</li> </ul> <p></p>","title":"Architecture"},{"location":"ethereum/api/ethereum-api-indexer/#controllers","text":"<ol> <li>To create or modify NFTs and search information about them:<ul> <li>nft-transaction-controller</li> <li>nft-lazy-mint-controller</li> <li>nft-activity-controller</li> <li>nft-ownership-controller</li> <li>nft-item-controller</li> <li>nft-collection-controller</li> </ul> </li> <li>To create or modify orders and search information about them:<ul> <li>order-signature-controller</li> <li>order-encode-controller</li> <li>order-controller</li> <li>order-transaction-controller</li> <li>order-activity-controller</li> <li>order-aggregation-controller</li> <li>nft-order-ownership-controller</li> <li>nft-order-item-controller</li> <li>nft-order-activity-controller</li> <li>nft-order-collection-controller</li> </ul> </li> <li>Additional controllers:<ul> <li>gateway-controller</li> <li>erc20-balance-controller</li> <li>erc20-token-controller</li> <li>lock-controller</li> </ul> </li> </ol>","title":"Controllers"},{"location":"ethereum/api/ethereum-api-indexer/#api-usage-examples","text":"<ul> <li>Search Items</li> <li>Search Orders</li> <li>Create Lazy Minting</li> <li>Create Orders</li> </ul>","title":"API usage Examples"},{"location":"ethereum/api/search-items/","text":"<p>The main requests for working with Items relate to the nft-item-controller. Let's look at the example of getNftAllItems.</p>","title":"Search Items"},{"location":"ethereum/api/search-items/#getnftallitems","text":"<p>It will return all NFT items.</p> <p>Example request:</p> <pre><code>curl --request GET 'https://ethereum-api.rarible.org/v0.1/nft/items/all?size=1'\n</code></pre> <p>Request parameters:</p> <ul> <li>size \u2014 the number of items to be returned</li> <li>showDeleted \u2014 display deleted items or not</li> <li>lastUpdatedFrom \u2014 returns items that have been updated since that date (timestamp in ms)</li> <li>lastUpdatedTo \u2014 returns items that have been updated to this date (timestamp in ms)</li> <li>continuation \u2014 continuation token from the previous response</li> </ul> <p>Response example (status 200):</p> <pre><code>{\n    \"total\": 1,\n    \"continuation\": \"1637677864204_0xf6793da657495ffeff9ee6350824910abc21356c:0x8108800667cb3859020c77f7643cedb794b4455700000000000000000000000e\",\n    \"items\": [\n        {\n            \"id\": \"0xf6793da657495ffeff9ee6350824910abc21356c:58363375839982426315252321964399886024230569048144758096248518895130164330510\",\n            \"contract\": \"0xf6793da657495ffeff9ee6350824910abc21356c\",\n            \"tokenId\": \"58363375839982426315252321964399886024230569048144758096248518895130164330510\",\n            \"creators\": [\n                {\n                    \"account\": \"0x8108800667cb3859020c77f7643cedb794b44557\",\n                    \"value\": 10000\n                }\n            ],\n            \"supply\": \"1\",\n            \"lazySupply\": \"1\",\n            \"owners\": [\n                \"0x8108800667cb3859020c77f7643cedb794b44557\"\n            ],\n            \"royalties\": [\n                {\n                    \"account\": \"0x8108800667cb3859020c77f7643cedb794b44557\",\n                    \"value\": 1000\n                }\n            ],\n            \"date\": \"2021-11-23T14:31:04.204Z\",\n            \"pending\": [],\n            \"deleted\": false,\n            \"meta\": {\n                \"name\": \"Rampows the Daltons\",\n                \"description\": \"\",\n                \"attributes\": [],\n                \"image\": {\n                    \"url\": {\n                        \"ORIGINAL\": \"ipfs://ipfs/QmWXtdxkrR33rNxoNAbUDELsv2YBjajE4nhHGrgwT7UBHQ/image.jpeg\"\n                    },\n                    \"meta\": {\n                        \"ORIGINAL\": {\n                            \"type\": \"image/jpeg\",\n                            \"width\": 1792,\n                            \"height\": 1401\n                        }\n                    }\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>total \u2014 the number of items returned on request</li> <li>continuation \u2014 continuation token from the previous response</li> <li>items \u2014 list of found items &amp; basic information about them</li> </ul>","title":"getNftAllItems"},{"location":"ethereum/api/search-orders/","text":"<p>The main requests for working with Orders refer to order-controller. Let's look at the example of getOrdersAllByStatus.</p>","title":"Search Orders"},{"location":"ethereum/api/search-orders/#getordersallbystatus","text":"<p>Returns all orders sorted by status.</p> <p>Example request:</p> <pre><code>curl --request GET 'https://ethereum-api.rarible.org/v0.1/order/orders/all/byStatus?sort=LAST_UPDATE_DESC&amp;size=1&amp;status=ACTIVE'\n</code></pre> <p>Request parameters:</p> <ul> <li>sort  \u2014 sort by last updated orders <code>LAST_UPDATE_ASC</code>, <code>LAST_UPDATE_DESC</code></li> <li>size \u2014 number of orders to be returned</li> <li>continuation \u2014 continuation token from the previous response</li> <li>status \u2014 order status <code>ACTIVE</code>, <code>FILLED</code>, <code>HISTORICAL</code>, <code>INACTIVE</code>, <code>CANCELLED</code></li> </ul> <p>Response example (status 200):</p> <pre><code>{\n    \"orders\": [\n        {\n            \"type\": \"RARIBLE_V2\",\n            \"maker\": \"0x1a68bab3ebe18ffe95508b2d4e1362addc2cbdd6\",\n            \"make\": {\n                \"assetType\": {\n                    \"assetClass\": \"ERC20\",\n                    \"contract\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n                },\n                \"value\": \"260000000000000000\",\n                \"valueDecimal\": 0.260000000000000000\n            },\n            \"take\": {\n                \"assetType\": {\n                    \"assetClass\": \"ERC721\",\n                    \"contract\": \"0x918f677b3ab4b9290ca96a95430fd228b2d84817\",\n                    \"tokenId\": \"260\"\n                },\n                \"value\": \"1\",\n                \"valueDecimal\": 1\n            },\n            \"fill\": \"0\",\n            \"fillValue\": 0,\n            \"makeStock\": \"260000000000000000\",\n            \"makeStockValue\": 0.260000000000000000,\n            \"cancelled\": false,\n            \"salt\": \"0xf7f9ca62eceb7ee9021a89ac2a77976287721cc56a28f9d8d12c1332898e12e4\",\n            \"signature\": \"0x382bd104f4497119c75b36e5f0954a03692ab1c3b995266b20623bc718a58f423ff68e2caacb93668811e52b6a099260b3147ded35dc3ad5d65970efde9587761c\",\n            \"createdAt\": \"2021-11-23T15:08:20.925Z\",\n            \"lastUpdateAt\": \"2021-11-23T15:08:20.925Z\",\n            \"pending\": [],\n            \"hash\": \"0x3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\",\n            \"makeBalance\": \"0\",\n            \"takePrice\": 0.260000000000000000,\n            \"takePriceUsd\": 1089.887807206807960000000000000000,\n            \"priceHistory\": [\n                {\n                    \"date\": \"2021-11-23T15:08:20.925Z\",\n                    \"makeValue\": 0.260000000000000000,\n                    \"takeValue\": 1\n                }\n            ],\n            \"status\": \"ACTIVE\",\n            \"data\": {\n                \"dataType\": \"RARIBLE_V2_DATA_V1\",\n                \"payouts\": [],\n                \"originFees\": [\n                    {\n                        \"account\": \"0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\",\n                        \"value\": 250\n                    }\n                ]\n            }\n        }\n    ],\n    \"continuation\": \"1637680100925_3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\"\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>orders \u2014 list of found orders with basic information on them</li> <li>continuation \u2014 continuation token from the previous response</li> </ul>","title":"getOrdersAllByStatus"},{"location":"ethereum/metadata/ethereum-metadata/","text":"<p>Providing Assets Metadata allows applications to extract data for digital assets and display them in an application.</p> <p>URIs usually represent digital assets in a smart contract. Metadata allows assets to have additional properties, such as name, description, and image.</p>","title":"Ethereum Metadata"},{"location":"ethereum/metadata/ethereum-metadata/#tokenuri","text":"<p>To get metadata for ERC-721 and ERC-1155, you need to return the URI. To do this, use the function:</p> <ul> <li><code>tokenURI</code> in ERC-721</li> <li><code>uri</code> in ERC-1155.</li> </ul> <p>ERC-721</p> <pre><code>    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length &gt; 0) {\n            return LibURI.checkPrefix(base, _tokenURI);\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n</code></pre> <p>ERC-1155</p> <pre><code>    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n</code></pre> <p>The <code>tokenURI</code> or <code>uri</code> function returns an HTTP or IPFS URL. When requesting the URL, JSON with metadata for the token should be returned.</p>","title":"tokenURI"},{"location":"ethereum/metadata/ethereum-metadata/#metadata-structure","text":"<p>The Rarible Ethereum Protocol supports the Metadata structure according to the standards EIP-721 and EIP-1155.</p> <p>Example of a Metadata structure for ERC-1155 NFT:</p> <pre><code>{\n    \"name\": \"CryptoParrot#17\",\n    \"description\": \"The CryptoParrot is a collection of 10,000 unique Parrot NFTs\",\n    \"attributes\": [\n        {\n            \"key\": \"/background\",\n            \"value\": \"rust\"\n        },\n        {\n            \"key\": \"/body\",\n            \"value\": \"lavender down\"\n        },\n        {\n            \"key\": \"/color\",\n            \"value\": \"gray\"\n        },\n        {\n            \"key\": \"/eye\",\n            \"value\": \"small 1\"\n        },\n        {\n            \"key\": \"/head\",\n            \"value\": \"navy blue nightcap\"\n        },\n        {\n            \"key\": \"/mouth\",\n            \"value\": \"yellow 6\"\n        }\n    ],\n    \"image\": {\n        \"url\": {\n            \"ORIGINAL\": \"ipfs://ipfs/QmUoc2LDDnHxHsesLXtpxTLupzVuyfVkJomWWHmvKNCjrL/image.png\"\n        },\n        \"meta\": {\n            \"ORIGINAL\": {\n                \"type\": \"image/png\",\n                \"width\": 999,\n                \"height\": 999\n            }\n        }\n    }\n}\n</code></pre> <p>Description of properties:</p>    name  Name of the item     description  A human-readable description of the item   attributes key, value These are the attributes for the item   image url This is the URL to the image of the item    meta This is meta-information about media. Include type, width, and height   animation url This is the URL to the animation of the item    meta This is meta-information about media. Include type, width, and height    <p>For the Rarible Ethereum Protocol, it does not matter where the Metadata for NFT will be placed. See the example of uploading and using metadata with IPFS.</p>","title":"Metadata Structure"},{"location":"ethereum/metadata/ipfs-example/","text":"","title":"Example of uploading &amp; using Metadata with IPFS"},{"location":"ethereum/metadata/ipfs-example/#uploading-images-to-ipfs","text":"<p>To upload images to IPFS, will use the Pinata service.</p> <p>Here you can see an example using Node JS to upload an image using the Pinata API.</p> <pre><code>const axios = require(\"axios\");\nconst fs = require(\"fs\");\nconst FormData = require(\"form-data\");\n\nexport const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) =&gt; {\n  const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`;\n  let data = new FormData();\n\n  data.append(\"file\", fs.createReadStream(\"./yourfile.png\"));\n\n  return axios.post(url, data, {\n      headers: {\n        \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`,\n        pinata_api_key: pinataApiKey,\n        pinata_secret_api_key: pinataSecretApiKey,\n      },\n    })\n    .then(function (response) {\n      console.log(repsonse.IpfsHash);\n    })\n    .catch(function (error) {\n      console.log(error)\n    });\n};\n</code></pre> <p>Response to the request:</p> <pre><code>{\n    IpfsHash: // This is the IPFS multi-hash provided back for your content,\n    PinSize: // This is how large (in bytes) the content you just pinned is,\n    Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format)\n}\n</code></pre>","title":"Uploading images to IPFS"},{"location":"ethereum/metadata/ipfs-example/#creating-a-metadata-file-for-nft","text":"<p>With the <code>IpfsHash</code>, we can create a Metadata file. It will be connected to the NFT inside the blockchain network.</p> <pre><code>{\n   \"name\": /* NFT Name - This must be a string */,\n   \"description\": /* Description of the NFT - This must be a string */,\n   \"image\": /*  IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */,\n   \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */,\n   \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */,\n   // the below section is not needed.\n   \"attributes\": [\n      {\n         \"key\": /* Key name - This must be a string */,\n         \"trait_type\": /* Trait name - This must be a string */,\n         \"value\": /* Key Value - This must be a string */\n      }\n   ]\n}\n</code></pre>","title":"Creating a Metadata file for NFT"},{"location":"ethereum/metadata/ipfs-example/#adding-generated-metadata-to-ipfs","text":"<ol> <li> <p>Specify <code>external_url</code> in the format <code>${contractAddress}:${tokenId}</code>, for example:</p> <pre><code>\"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\"\n</code></pre> </li> <li> <p>Publish Metadata to IPFS:</p> <pre><code>var axios = require('axios');\nvar data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]});\n\nvar config = {\n  method: 'post',\n  url: 'https://api.pinata.cloud/pinning/pinFileToIPFS',\n  headers: { \n    'pinata_api_key': // KEY_HERE, \n    'pinata_secret_api_key': // SECRET_KEY_HERE, \n    'Content-Type': 'application/json'\n  },\n  data: data\n};\n\naxios(config).then(function (response) {\n  console.log(JSON.stringify(response.data));\n}).catch(function (error) {\n  console.log(error);\n});\n</code></pre> <p>Response example:</p> <pre><code>{\n    \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\",\n    \"PinSize\": 290,\n    \"Timestamp\": \"2021-02-10T14:06:09.255Z\"\n}\n</code></pre> </li> <li> <p>Attach the new <code>IpfsHash</code> to your NFT.</p> </li> </ol>","title":"Adding generated Metadata to IPFS"},{"location":"ethereum/sdk/ethereum-sdk/","text":"<p>Rarible Protocol Ethereum SDK enables apps to easily interact with Rarible protocol.</p> <p>Take a look at this sample app with React for a quick start.</p>","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#installation","text":"<pre><code>npm install -D @rarible/protocol-ethereum-sdk\n</code></pre> <p>or inject package into your web page with web3 instance</p> <pre><code>&lt;script src=\"https://unpkg.com/@rarible/web3-ethereum@0.10.0/umd/rarible-web3-ethereum.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"https://unpkg.com/@rarible/protocol-ethereum-sdk@0.10.0/umd/rarible-ethereum-sdk.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"https://unpkg.com/web3@1.6.0/dist/web3.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n</code></pre>","title":"Installation"},{"location":"ethereum/sdk/ethereum-sdk/#usage-with-web3js","text":"","title":"Usage with web3.js"},{"location":"ethereum/sdk/ethereum-sdk/#configure-and-create-rarible-sdk-object","text":"<pre><code>import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\"\n\nconst sdk = createRaribleSdk(web3, env, { fetchApi: fetch })\n</code></pre> <ul> <li>web3 - configured with your provider web3js client</li> <li>env - environment configuration name, it should accept one of these values <code>ropsten</code>, <code>rinkeby</code>, <code>mainnet</code> or <code>e2e</code></li> </ul>","title":"Configure and create Rarible SDK object"},{"location":"ethereum/sdk/ethereum-sdk/#configure-rarible-sdk-in-browser","text":"<pre><code>const web = new Web3(ethereum)\nconst web3Ethereum = new window.raribleWeb3Ethereum.Web3Ethereum({ web3: web })\nconst env = \"mainnet\" // \"e2e\" | \"ropsten\" | \"rinkeby\" | \"mainnet\"\nconst raribleSdk = new window.raribleEthereumSdk.createRaribleSdk(web3Ethereum, env)\n</code></pre> <ul> <li>ethereum - metamask browser instance (window.ethereum)</li> </ul>","title":"Configure Rarible SDK in browser"},{"location":"ethereum/sdk/ethereum-sdk/#usage-sdk-on-the-server-backend","text":"<p>The SDK was designed for use on the frontend side. To use the SDK on the server side (backend):</p> <ol> <li> <p>Install packages:</p> <pre><code>yarn add tslib@2.3.1\nyarn add form-data\nyarn add node-fetch\n</code></pre> </li> <li> <p>Add dependencies:</p> <pre><code>global.FormData = require(\"form-data\")\nglobal.window = {\n  fetch: require(\"node-fetch\"),\n  dispatchEvent: () =&gt; {\n  },\n}\nglobal.CustomEvent = function CustomEvent() {\n  return\n}\n</code></pre> </li> </ol> <p>For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.</p>","title":"Usage SDK on the server (backend)"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/","text":"<p>The main function of ExchangeV2 is matchOrders. This function takes two sides of order and attempts to match them.</p> <p>The matching order process can be divided into stages:</p> <ol> <li>Order Validation \u2014 checks if the order parameters are valid and the caller is authorized to execute the order.</li> <li>Asset Matching \u2014 checks the assets from left &amp; right order match and then extracts the matching assets.</li> <li>Calculating Fill \u2014 checks and finds out what exact values should be filled. Orders can also be matched partly. This occurs if one of the sides doesn't want to fill other orders completely.</li> <li>Order Execution, Transfers - execute the transfers of the assets, saving Order filling if necessary.</li> </ol>  <p> </p> Matching order","title":"ExchangeV2 Matching Orders"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#order-validation","text":"<ol> <li>Check the start/end date of the order.</li> <li>Check whether the receiver of this order is empty or the receiver is the same as order.taker.</li> <li>Check whether the order is signed by its creator or the creator of the order performs a transaction.</li> <li>If the creator of the order is a contract, then an ERC-1271 check is performed.</li> </ol> <p>Currently, only orders outside the blockchain network are supported. This part of the smart contract can be easily updated to support Order Book on-chain.</p>","title":"Order Validation"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#asset-matching","text":"<p>The main goal is to check that makeAsset (left) matches takeAsset (right) and vice versa.</p> <p>makeAsset is what you sell.</p> <ul> <li>The purchase order is what you pay for the seller's NFT. It can be ERC-20, ERC-721, ERC-1155, or any custom resource that uses the asset mapping interface.</li> <li>The sales order is the NFT that you are selling.</li> </ul> <p>takeAsset is what you accept in return.</p> <ul> <li>The purchase order is the NFT that you are buying.</li> <li>The sales order is what you are willing to accept.</li> </ul> <p>New asset types can be added without updating the smart contract. You can do it with a custom IAssetMatcher.</p> <p>Possible improvements:</p> <ul> <li>Support for parametric assets. For example, a user can place an order to exchange 10 ETH for any NFT from a popular collection.</li> <li>Support for NFT packages.</li> </ul>","title":"Asset Matching"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#calculating-fill-and-order-execution","text":"<p>The order fill is stored inside the smart contract and refers to the taking part of the order. Fill is stored inside the mapping slot, the key to which is calculated using the fields:</p> <ul> <li>maker</li> <li>make asset type</li> <li>take asset type</li> <li>salt</li> </ul> <p>Fill orders that differ only in the exchange rate are stored in one mapping slot.</p> <p>In addition, full filled orders can be expanded: users can sign new orders using the same salt. For example, they can increase make.value and take.value.</p> <p>Priority of the order rate \u2014 if the exchange rates differ, but orders can be filled (for example, the left order is 10X -&gt; 100Y, and the right one is 100Y -&gt; 5X), then the part on the left determines the exchange rate.</p> <p>Rounding errors \u2014 mathematical operations calculate the filling volumes. When rounding is performed and the error exceeds 0.1%, a rounding error will be issued, and the order will not be executed.</p>","title":"Calculating Fill and Order Execution"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#transfer-execution","text":"<p>Transfers are made using RaribleTransferManager. It takes into account protocol commissions, royalties, etc.</p> <p>It is planned to expand the RaribleTransferManager to support more royalty schemes and add new features. For example, user fees or multiple order recipients.</p> <p>This part of the algorithm can be extended using ITransferExecutor. It will be added new executors to support new asset types. For example, an executor may be added to process packages.</p> <p>Possible improvements:</p> <ul> <li>Package support.</li> <li>Support for random boxes.</li> </ul>","title":"Transfer Execution"},{"location":"ethereum/smart-contracts/exchangev2-overview/","text":"<p>ExchangeV2 is a smart contract for the decentralized exchange of any assets represented in the Ethereum blockchain (or EVM compatible).</p> <p>To make an exchange two orders are required:</p> <ol> <li>Sale Order \u2014 Created by the seller.</li> <li>Purchase Order \u2014 Bid made by the buyer.</li> </ol> <p>The exchange occurs if the two orders above match.</p> <p>The general process of creating and executing an order is as follows:</p> <ol> <li>The seller confirms that the exchange contract can dispose of their assets/tokens.</li> <li>The seller creates and signs an order. Specifies the types and amounts of assets they want to receive in return.</li> <li>The seller sends the order to the indexer.</li> <li>The buyer sends an indexer request to get an order for a specific item or collection.</li> <li>The buyer creates a bid.</li> <li>If the order and bid are matched, an exchange takes place.</li> <li>If the order and bid do not match, then the seller can accept the Bid or not. If it accepts, then an exchange takes place.</li> </ol> <p>The order can be signed or not. The signature may be missing if the transaction is executed by the person who created this order.</p>  <p> </p> Creating and executing the order  <p>See more information about:</p> <ul> <li>ExchangeV2 Matching Orders</li> <li>ExchangeV2 Sell and Bid</li> <li>ExchangeV2 Update and Cancel</li> </ul>","title":"ExchangeV2 Overview"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/","text":"","title":"ExchangeV2 Sell and Bid"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#sell-order","text":"<p>To create a Sell Order, use the Ethereum SDK:</p> <ol> <li>Check that the exchange contract can dispose of assets, tokens. Call setApprovalForAll if necessary.</li> <li>Create a signature:<ol> <li>Encrypt the order for signing.</li> <li>Sign the order.</li> </ol> </li> <li>Send the signed order to the API.</li> </ol> <p>Example of creating a Sell Order in SDK.</p>","title":"Sell Order"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#bid","text":"<p>To make a purchase or accept a Bid, send a transaction to the matchOrders function of the contract ExchangeV2.</p> <p>matchOrders function has parameters:</p> <ul> <li>left order</li> <li>left order signature</li> <li>right order</li> <li>right order signature</li> </ul> <p>Example of creating a Bid in SDK.</p>","title":"Bid"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/","text":"","title":"ExchangeV2 Update and Cancel"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#update","text":"<p>To update the order:</p> <ol> <li>Make changes.</li> <li>Send a request to the API (see Sell Order).</li> </ol> <p>New orders check the: start, end, take, make and value fields.</p> <p>The price can only be reduced. You will need to cancel the order and create a new one to increase the price. Since if the user has already signed a message with a lower price, someone could save this message and signature. You can't cancel it without contacting the contract.</p>","title":"Update"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#cancel","text":"<p>To cancel the order, call the cancellation method in the ExchangeV2 contract.</p> <pre><code>function cancel(LibOrder.Order memory order) public {\n require(_msgSender() == order.maker, \"not a maker\");\n bytes32 orderKeyHash = LibOrder.hashKey(order);\n fills[orderKeyHash] = UINT256_MAX;\n emit Cancel(orderKeyHash);\n}\n</code></pre> <p>An error will be returned when matching such an order.</p> <p>Orders makers can only call this function. It marks orders that cannot be filled.</p>","title":"Cancel"},{"location":"ethereum/smart-contracts/fees/","text":"<p>RaribleTransferManager supports the following types of fees:</p> <ul> <li>Protocol fees \u2014 are charged on both sides of the transaction.</li> <li>Origin fees \u2014 set for each order. It may differ for two orders.</li> <li>Royalties \u2014 the author of the work will receive a part of each sale.</li> </ul>","title":"Fees"},{"location":"ethereum/smart-contracts/fees/#algorithm","text":"<p>The transfer of assets takes place inside the <code>doTransfers</code>. The following parameters are used as arguments:</p> <ul> <li><code>LibAsset.AssetType</code> <code>makeMatch</code> \u2014 <code>AssetType</code> on the make-side order</li> <li><code>LibAsset.AssetType</code> <code>takeMatch</code> \u2014 <code>AssetType</code> on the take-side order</li> <li><code>LibFill.FillResult</code> <code>fill</code> \u2014 values on both sides that will be passed by match</li> <li><code>LibOrder.Order</code> <code>leftOrder</code> \u2014 left order data</li> <li><code>LibOrder.Order</code> <code>rightOrder</code> \u2014 right order data</li> </ul> <p>In this method, the following actions are performed.</p>","title":"Algorithm"},{"location":"ethereum/smart-contracts/fees/#how-do-we-calculate-the-commission-side-of-the-transaction","text":"<ol> <li>Use <code>LibFeeSide.getFeeSide</code>. It takes as arguments <code>assetClasses</code> of both sides (for example, <code>ETH</code> and <code>ERC20</code>).</li> <li><code>LibFeeSide.getFeeSide</code> tries to determine side to pay fees:</li> </ol> <p></p> <ul> <li>If there is ETH on any side of the transaction, it is used.</li> <li>If there is no ETH, we check if there is an ERC-20 and use it.</li> <li>If there is no ERC-20, check if there is an ERC-1155 and use it.</li> <li>Otherwise, no fee will be charged. (e.g. if two ERC-721 are involved in the transaction)</li> </ul>","title":"How do we calculate the commission side of the transaction?"},{"location":"ethereum/smart-contracts/fees/#transfer","text":"<ol> <li>If the make-side pays fees:<ul> <li>calling <code>doTransfersWithFees</code> for the make-side</li> <li>calling <code>transferPayouts</code> for the take-side</li> </ul> </li> <li>If the take-side pays fees:<ul> <li>calling <code>doTransfersWithFees</code> for the take-side</li> <li>calling <code>transferPayouts</code> for the make-side</li> </ul> </li> <li>If the side for the payment of fees are not defined:<ul> <li>call <code>transferPayouts</code> for both sides</li> </ul> </li> </ol> <p>When computing the total amount of the asset:</p> <ul> <li>The protocol fee is added on top of the filled amount.</li> <li>The fee for sending the buyer's order is also added on top.</li> </ul> <p>If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens.</p> <p>If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction.</p> <p>For more information about fees, see the page RaribleTransferManager on GitHub.</p>","title":"Transfer"},{"location":"ethereum/smart-contracts/royalties/","text":"","title":"Royalties"},{"location":"ethereum/smart-contracts/royalties/#royalties-v2","text":"<p>Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts.</p> <p>It exposes <code>getRoyalties</code> method, which expects an ID as input (usually tokenId) and returns an array of accounts &amp; basis points.</p> <pre><code>function getRaribleV2Royalties(uint256 id) override external view returns (LibPart.Part[] memory) {\n        return royalties[id];\n}\n</code></pre>","title":"Royalties V2"},{"location":"ethereum/smart-contracts/royalties/#royalties-v1","text":"<p>The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry. The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array.</p> <p>This allows for Rarible to support different royalty standards for different collections.</p> <p>Rarible Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function.</p> <p>This tuple is made up of two variables, fees.recipient and fees.value.</p> <ul> <li>fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received.</li> <li>fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here.</li> </ul> <p>Below you can find the code block from ExchangeV1, which handles the on-chain royalties.</p> <pre><code>contract HasSecondarySaleFees is ERC165 {\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\n    /*\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n     *\n     * =&gt; 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\n     */\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\n    constructor() public {\n        _registerInterface(_INTERFACE_ID_FEES);\n    }\n    function getFeeRecipients(uint256 id) public view returns (address payable[] memory);\n    function getFeeBps(uint256 id) public view returns (uint[] memory);\n}\n</code></pre>","title":"Royalties V1"},{"location":"ethereum/smart-contracts/royalties/#examples","text":"<ul> <li>Setting Up Royalties on an External Collection</li> </ul>","title":"Examples"},{"location":"ethereum/smart-contracts/smart-contracts/","text":"<p>Rarible Smart Contracts for Ethereum consist of:</p> <ul> <li>Exchange V2 \u2014 purchase and sale of tokens</li> <li>Tokens, TokenFactories \u2014 tokens contracts and Token Factories</li> <li>RoyaltiesRegistry \u2014 embedded royalties in NFT</li> <li>RoyaltiesProviders \u2014 commissions getting from individual contracts</li> <li>TransferProxy \u2014 token exchange according of the type</li> <li>Staking \u2014 tokens deposit in exchange for raising points. That makes it possible to take an active part in solving DAO issues</li> <li>Auctions \u2014 fixed-bid auction</li> <li>OnChainOrders \u2014 will be added to ExchangeV2 soon</li> </ul> <p>Let's look closer at the following components:</p> <ul> <li>Exchange V2</li> <li>Tokens</li> <li>Fees</li> <li>Royalties</li> </ul> <p>For more information on using Rarible Smart Contracts, see the page Protocol Contracts on GitHub.</p>","title":"Smart Contracts Overview"},{"location":"ethereum/smart-contracts/tokens/","text":"<p>Rarible Protocol Ethereum supports two types of tokens:</p> <ul> <li>ERC-721 is a standard interface for non-interchangeable tokens. This type of token is unique and may have a value different from the value of another token from the same smart contract.</li> <li>ERC-1155 is a standard interface for contracts that manage multiple types of tokens. One deployed contract can include any combination of interchangeable tokens, non-interchangeable tokens, or other configurations.</li> </ul> <p>You can mint both types of tokens as follows:</p> <ul> <li>A regular minting in a blockchain network using a contract.</li> <li>Lazy minting \u2014 minting of the token occurs outside the blockchain network. Entry into the blockchain and payment for gas is made when the token is purchased or transferred.</li> </ul> <p>Users can create tokens in different smart contracts.</p> <p>Tokens also support saving information about Royalties and information about all creators.</p>","title":"Tokens"},{"location":"ethereum/smart-contracts/tokens/#token-factories","text":"<p>To create ERC-721 and ERC-1155 smart contracts, use our Token Factories. The addresses are available on the Contract Addresses page.</p> <p>Using Token Factories, you can create the following types of smart contracts:</p> <ul> <li>Public ERC-721 and ERC-1155</li> <li>Private ERC-721 and ERC-1155</li> </ul> <p>Token Factories create beacon proxy servers. Rarible Protocol can automatically update these contracts when all token contracts are updated.</p>","title":"Token Factories"},{"location":"ethereum/smart-contracts/tokens/#minting","text":"<p>Minting is using the <code>mintAndTransfer</code> function for ERC-721 and ERC-1155 contracts.</p> <p>For ERC-721, the function has the following signature:<code>mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to)</code>.</p> <pre><code>struct Mint721Data {\n        uint tokenId;\n        string tokenURI;\n        address[] creators;\n        LibPart.Part[] royalties;\n        bytes[] signatures;\n}\n</code></pre> <ul> <li>tokenId \u2014 tokenId of the ERC-721 standard</li> <li>tokenURI \u2014 suffix for the token URI. The prefix is usually <code>ipfs:/</code></li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.</li> </ul> <p>For ERC-1155, the function has the following signature: <code>mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount)</code>.</p> <pre><code>struct Mint1155Data {\n        uint tokenId;\n        string tokenURI;\n        uint supply;\n        address[] creators;\n        LibPart.Part[] royalties;\n        bytes[] signatures;\n}\n</code></pre> <ul> <li>tokenId \u2014 tokenId of the ERC-1155 standard</li> <li>tokenURI \u2014 suffix for the token URI. The prefix is usually <code>ipfs:/</code></li> <li>supply \u2014 total number of tokens for minting</li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.</li> </ul>","title":"Minting"},{"location":"ethereum/smart-contracts/tokens/#lazy-minting","text":"<p></p> <p>Lazy Minting is supported for ERC-721 and ERC-1155.</p> <p>To create Lazy Minting:</p> <ol> <li>Generate a token ID.</li> <li>Create a Lazy Minting request body that the creator must sign.</li> <li>The creator signs the provided data.</li> <li>Add signature to the request body</li> <li>Send the data to the API.</li> </ol> <p>See an example of creating Lazy Minting by using API.</p> <p>For more information about Lazy Minting, see SDK page. </p>","title":"Lazy Minting"},{"location":"ethereum/smart-contracts/tokens/#transfer","text":"<p>This function transfers the token from the sender to the new owner.</p> <p>Arguments:</p> <ul> <li>owner: Address \u2014 address of the asset owner</li> <li>asset: Asset \u2014 asset type</li> </ul> <p>The function checks the asset type and performs one of the following functions:</p> <ul> <li>transferErc721</li> <li>transferErc1155</li> </ul> <p>transferErc1155 arguments:</p> <pre><code>export async function transferErc1155(\n    ethereum: Ethereum,\n    send: SendFunction,\n    contract: Address,\n    from: Address,\n    to: Address,\n    tokenId: string | string[],\n    tokenAmount: string | string[]\n</code></pre> <ul> <li>contract: Address \u2014 contract address ERC-1155</li> <li>from: Address \u2014 address of the ERC-1155 token owner</li> <li>to: Address \u2014 address of the new owner</li> <li>tokenId: string | string[] \u2014 token ID or token array for transfer</li> <li>tokenAmount: string | string[] \u2014 number of ERC-1155 tokens or an array of tokens for transfer</li> </ul> <p>transferErc721 arguments:</p> <pre><code>export async function transferErc721(\n    ethereum: Ethereum,\n    send: SendFunction,\n    contract: Address,\n    from: Address,\n    to: Address,\n    tokenId: string\n</code></pre> <ul> <li>contract: Address \u2014 contract address ERC-721</li> <li>from: Address \u2014 address of the ERC-721 token owner</li> <li>to: Address \u2014 address of the new owner</li> <li>tokenId: string | string[] \u2014 token ID for transfer</li> </ul>","title":"Transfer"},{"location":"ethereum/smart-contracts/tokens/#deploy","text":"<p>TODO</p>","title":"Deploy"},{"location":"ethereum/smart-contracts/tokens/#burn","text":"<p>To Burn a token, call the function:</p> <pre><code>const hash = await sdk.nft.burn({\n    contract: contractAddress,\n    tokenId: toBigNumber(tokenId),\n})\n</code></pre> <ul> <li>contract \u2014 smart contract address</li> <li>tokenId \u2014 token identifier</li> </ul>","title":"Burn"},{"location":"flow/flow-api-indexer/","text":"<p>Rarible Protocol Flow NFT Indexer is a spring boot application for indexing Flow blockchain and API for reading NFT.</p>","title":"API and Indexer Overview"},{"location":"flow/flow-api-indexer/#architecture","text":"<p>The Rarible Protocol Flow indexer consists of the following parts:</p> <ul> <li>Backend API \u2014 Flow API implementation</li> <li>Scanner \u2014 core indexing functionality</li> </ul> <p>To read NFT events, we need to add <code>Subscriber</code> (see <code>com.rarible.flow.scanner.subscriber</code> package) with the event's description (usually contract name and event name) and start block height.</p> <p>The service uses Kafka to exchange messages with other Rarible services.</p> <p>The service also uses MongoDB as a persistence storage.</p>","title":"Architecture"},{"location":"flow/flow-api-indexer/#controllers","text":"<ol> <li> <p>To create or modify NFTs and search information about them:</p> <ul> <li>flow-nft-item-controller</li> <li>flow-nft-ownership-controller</li> <li>flow-nft-collection-controller</li> </ul> </li> <li> <p>To create or modify orders and search information about them:</p> <ul> <li>flow-order-controller</li> <li>flow-nft-order-activity-controller</li> <li>flow-nft-order-item-controller</li> <li>order-aggregation-controller</li> </ul> </li> <li> <p>Additional controllers:</p> <ul> <li>flow-nft-crypto-controller</li> </ul> </li> </ol> <p>For more information, see Flow Indexer and Flow OpenAPI repos on GitHub.</p>","title":"Controllers"},{"location":"flow/flow-overview/","text":"","title":"Rarible Protocol Flow"},{"location":"flow/flow-overview/#overview","text":"<p>Rarible Protocol Flow combines smart contracts for minting, exchanging tokens, APIs for order creation, discovery, standards used in smart contracts.</p> <p>Main features:</p> <ul> <li>Minting:</li> <li>Exchange (List, Sell/Buy):<ul> <li>On-chain mechanics of listing and buying items.</li> <li>Safe removal of an item from the sale if the item has been moved or burned after being put up for sale.</li> <li>Multiple asset types are supported to fill orders: FT and NFT.</li> <li>Supported FT:<ul> <li>FLOW</li> <li>FUSD</li> <li>FT</li> </ul> </li> </ul> </li> <li>Indexer:<ul> <li>Provides ways to query NFT for contracts that you want to monitor.</li> <li>Exposes ways to create orders.</li> </ul> </li> </ul>","title":"Overview"},{"location":"flow/flow-overview/#smart-contracts","text":"<p>Here you can find Rarible Smart Contracts deployed instances across Flow Testnet and Mainnet.</p>    Smart Contract Mainnet Testnet     RaribleNFT A.01ab36aaf654a13e.RaribleNFT A.ebf4ae01d1284af8.RaribleNFT   RaribleOrder A.01ab36aaf654a13e.RaribleOrder A.ebf4ae01d1284af8.RaribleOrder   RaribleFee A.336405ad2f289b87.RaribleFee A.ebf4ae01d1284af8.RaribleFee   LicensedNFT A.01ab36aaf654a13e.LicensedNFT A.ebf4ae01d1284af8.LicensedNFT    <p>For more information, see Rarible Protocol Flow Smart Contracts repo on GitHub.</p>","title":"Smart Contracts"},{"location":"flow/flow-overview/#api-reference","text":"<p>Subject to change</p> <p>The following APIs are used for internal work and can change in future versions.</p>  <p>Use these base URLs to access our API on different Flow networks:</p>    Base URL Network     https://flow-api.rarible.com/v0.1 Mainnet   https://flow-api-staging.rarible.com/v0.1 Testnet   http://flow-api-dev.rarible.com/v0.1 Testnet    <p>Flow API documentation can be found here:</p> <ul> <li>Mainnet</li> <li>Staging</li> <li>Development</li> </ul> <p>For more information, see Flow Indexer and Flow OpenAPI repos on GitHub.</p>","title":"API Reference"},{"location":"flow/flow-overview/#sdk","text":"<p>Rarible Protocol Flow SDK enables applications to interact with Rarible Flow protocol easily.</p> <p>With the Rarible Protocol Flow SDK, you can:</p> <ul> <li>Authenticate customer</li> <li>Logout customer</li> <li>Make regular mint</li> <li>Transfer tokens</li> <li>Burn tokens</li> <li>Create sell orders</li> <li>Cancel sell order</li> <li>Buy tokens for regular sell orders</li> <li>Sign user message</li> </ul>","title":"SDK"},{"location":"flow/flow-sdk/","text":"<p>Rarible Protocol Flow SDK enables applications to interact with Rarible Flow protocol easily.</p>","title":"Flow SDK"},{"location":"flow/flow-sdk/#installation","text":"<pre><code>npm i -S @rarible/flow-sdk\n</code></pre>","title":"Installation"},{"location":"flow/flow-sdk/#usage","text":"<ol> <li>Configure fcl</li> <li>Create and use flow-sdk</li> </ol>","title":"Usage"},{"location":"flow/flow-sdk/#configure-fcl","text":"<p>Flow-sdk use @onflow/fcl-js. You can find configuration details for fcl in this page</p> <pre><code>//example config for testnet\nimport { config } from \"@onflow/fcl\";\nconfig({\n  \"accessNode.api\": \"https://access-testnet.onflow.org\", // Mainnet: \"https://access-mainnet-beta.onflow.org\"\n  \"discovery.wallet\": \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\"\n})\n</code></pre>","title":"Configure fcl"},{"location":"flow/flow-sdk/#create-and-use-flow-sdk","text":"<p>Then we create the SDK according to the network that we configured in the previous step.</p> <pre><code>import { createFlowSdk } from \"@rarible/flow-sdk\"\nimport * as fcl from \"@onflow/fcl\"\nconst sdk = createFlowSdk(fcl, \"testnet\")\n</code></pre>","title":"Create and use flow-sdk"},{"location":"flow/flow-sdk/#minting","text":"<p>Mint response represents transaction result extended with <code>txId</code> and minted <code>tokenId</code></p> <pre><code>const {\n  txId, // transaction id\n  tokenId, // minted tokenId\n  status, // flow transaction status\n  statusCode, // flow transaction statusCode - for example: value 4 for sealed transaction\n  errorMessage,\n  events, // events generated from contract and include all events produced by transaction, deopsits withdrown etc.\n} = await sdk.nft.mint(collection, \"your meta info\", [])\n</code></pre>","title":"Minting"},{"location":"flow/flow-sdk/#transfer","text":"<pre><code>const {\n  status,\n  statusCode,\n  errorMessage,\n  events,\n} = await sdk.nft.transfer(collection, tokenId, toFlowAddress)\n</code></pre>","title":"Transfer"},{"location":"flow/flow-sdk/#burn","text":"<pre><code>const {\n  status,\n  statusCode,\n  errorMessage,\n  events,\n} = await sdk.nft.burn(collection, tokenId)\n</code></pre>","title":"Burn"},{"location":"flow/flow-sdk/#create-sell-order","text":"<pre><code>const {\n  status,\n  statusCode,\n  errorMessage,\n  events,\n} = await sdk.nft.sell(collection, currency, tokenId, price)\n// supported currencies for now \"FLOW\" and \"FUSD\"\n// price must be a string of flow fungible token amount with 8 decimals,  for example: 1.123 or 0.1 or 0.00000001\n</code></pre>","title":"Create sell order"},{"location":"flow/flow-sdk/#update-order","text":"<pre><code>const {\n  status,\n  statusCode,\n  errorMessage,\n  events,\n} = await sdk.nft.sell(collection, currency, orderId, price)\n// supported currencies for now \"FLOW\" and \"FUSD\"\n// price must be a string of flow fungible token amount with 8 decimals,  for example: 1.123 or 0.1 or 0.00000001\n</code></pre>","title":"Update order"},{"location":"flow/flow-sdk/#cancel-order","text":"<pre><code>const {\n  status,\n  statusCode,\n  errorMessage,\n  events,\n} = await sdk.nft.sell(collection, orderId)\n</code></pre>","title":"Cancel order"},{"location":"flow/flow-sdk/#buy-an-item","text":"<pre><code>const {\n  status,\n  statusCode,\n  errorMessage,\n  events,\n} = await sdk.nft.fill(collection, orderId, owner)\n</code></pre> <p>For more information on using the Rarible Protocol Flow SDK, see the page Flow SDK on GitHub.</p>","title":"Buy an item"},{"location":"flow/flow-smart-contracts/","text":"<p>Rarible Smart Contracts for Flow consist of:</p> <ul> <li><code>RaribleFee</code> \u2014 fee manager that holds the rates and addresses fees.</li> <li><code>LicensedNFT</code> \u2014 contract interface adds royalties to NFT. You can implement this <code>LicensedNFT</code> in your contract (along with <code>NonFungibleToken</code>), and your royalties will be taken when trading on Rarible.</li> <li><code>RaribleNFT</code> \u2014 Rarible NFT contract that implements the Flow NFT standard is equivalent to ERC-721 or ERC-1155 on Ethereum.</li> <li><code>RaribleOrder</code> \u2014 marketplace contract is the wrapper for the standard NFTStorefront for handling market orders.</li> </ul> <p>For more information, see Rarible Protocol Flow Smart Contracts repo on GitHub.</p>","title":"Flow Smart Contracts Overview"},{"location":"flow/flow-smart-contracts/#matching-orders","text":"<p>Direct purchase of the item for sale is currently available. This means that you cannot bid on purchasing the item yet. But you can purchase an item for the amount the owner estimates the item.</p> <p>The purchase can be divided into several stages:</p> <ul> <li>Submit an item for sale</li> <li>Purchase of an item</li> </ul>","title":"Matching Orders"},{"location":"flow/flow-smart-contracts/#listing-an-item-for-sale","text":"<p>To list an item for sale, the seller has to:</p> <ul> <li>Select the item</li> <li>Indicate its cost</li> </ul> <p>For more information, see Rarible Protocol Flow SDK.</p> <p>At the moment of placing an item for sale in a smart contract, all payments are calculated and recorded.</p> <p>A smart contract implements such types of payments as:</p> <ul> <li>Commission for the sale of an item \u2014 it's 2.5% of the item's value, which the seller set. The seller pays the commission.</li> <li>Commission for the purchase of the item \u2014 it's 2.5% of the item's value, which the seller set. The buyer pays the commission.</li> <li>Royalties \u2014 are paid on the item's value as determined by the seller.</li> <li>Payment to the seller \u2014 the remainder of the item's value, minus the item's sale commission and royalties.</li> </ul> <p>Thus, the seller, putting up an item with a royalty of 10% for sale for 100 FLOW, will receive 87.5 FLOW as he pays: 2.5 FLOW commissions and 10 FLOW royalties after the sale.</p> <p>The buyer under the same conditions will purchase the item for 102.5 FLOW, where 2.5 FLOW will be counted as a commission.</p>  <p>If, after placing an item for sale, the item is transferred to another user or destroyed, the smart contract will automatically remove the item from the sale.</p>","title":"Listing an item for sale"},{"location":"flow/flow-smart-contracts/#buying-an-item","text":"<p>The buyer needs to provide the order ID and the item owner to buy an item. During the execution of the transaction, the buyer must have sufficient funds to purchase the item.</p> <p>For more information, see Rarible Protocol Flow SDK.</p>","title":"Buying an item"},{"location":"flow/flow-smart-contracts/#coming-soon","text":"<p>Soon we will implement the following features:</p> <ul> <li>Put an item up for auction</li> <li>Place a bid on an item</li> <li>Accept a bid</li> </ul>","title":"Coming soon"},{"location":"getting-started/community/","text":"","title":"Community and resources"},{"location":"getting-started/community/#dao","text":"<p>If you're a builder or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders.</p> <ul> <li>Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol.</li> <li>Github is where everything lives. Since we are open-source, many resources and help from other builders are available there.</li> <li>Notion is the platform where we hold information for DAO members and $RARI token holders.</li> <li>OpenAPI is where we document the current API capabilities.</li> <li>DAO Twitter</li> </ul>","title":"DAO"},{"location":"getting-started/community/#resources","text":"<ul> <li>Rarible Youtube</li> <li>Rarible Twitter</li> <li>Rarible Hackathon Docs HackMD by Isaac for Ethereum network.</li> </ul>","title":"Resources"},{"location":"getting-started/community/#submitting","text":"<p>You are welcome to suggest features and report bugs found! You can do it here:</p> <ul> <li>Submit an issue</li> <li>Submit a question or suggestion</li> </ul>","title":"Submitting"},{"location":"getting-started/community/#audits","text":"<p>Rarible Protocol is audited. Check this report by ChainSecurity.com.</p>","title":"Audits"},{"location":"getting-started/community/#license","text":"<p>Rarible Protocol is available under GPL v3.</p> <p>SDK and OpenAPI (with generated clients) are available under MIT.</p>","title":"License"},{"location":"getting-started/glossary/","text":"<p>This document contains a glossary with an alphabetical list, definitions, and terms related to API.</p> <p>A  |  B  |  C  |  E  |  I  |  F  |  L  |  M  |  N  |  O  |  P  |  R  |  S  |  T</p>","title":"Glossary"},{"location":"getting-started/glossary/#a","text":"<p>API</p> <p>Application Programming Interface enables different systems to interact with each other programmatically.</p> <p>Activity</p> <p>Event history with orders or NFT tokens.</p> <p>Asset Type</p> <p>Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.).</p> <p>Asset Class</p> <p>Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.).</p>","title":"A"},{"location":"getting-started/glossary/#b","text":"<p>Bid</p> <p>Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it.</p> <p>Burn</p> <p>Burning NFT effectively destroys the token and removes it entirely from the blockchain.</p>","title":"B"},{"location":"getting-started/glossary/#c","text":"<p>Collection</p> <p>NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted.</p> <p>Continuation</p> <p>Continuation token from the previous response.</p> <p>Contract</p> <p>Address of the Smart Contract.</p> <p>Creator</p> <p>Address of the NFT item creator.</p>","title":"C"},{"location":"getting-started/glossary/#e","text":"<p>ERC-20</p> <p>The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token.</p> <p>ERC-721</p> <p>The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract.</p> <p>ERC-1155</p> <p>The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.</p>","title":"E"},{"location":"getting-started/glossary/#i","text":"<p>Item</p> <p>Address of the NFT item. Id of the Item has format <code>${contract}:${tokenId}</code>.</p>","title":"I"},{"location":"getting-started/glossary/#f","text":"<p>Fee</p> <p>Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.</p>","title":"F"},{"location":"getting-started/glossary/#l","text":"<p>Lazy Mint</p> <p>The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.</p>","title":"L"},{"location":"getting-started/glossary/#m","text":"<p>Make</p> <p>Make the side of the Order. Make - what maker (order creator) has.</p> <p>Maker</p> <p>Creator of the order.</p> <p>Mint, Minting</p> <p>Minting is the act of publishing a unique instance of the token on the blockchain.</p>","title":"M"},{"location":"getting-started/glossary/#n","text":"<p>NFT</p> <p>Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.</p>","title":"N"},{"location":"getting-started/glossary/#o","text":"<p>Origin Fee</p> <p>Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize.</p> <p>Owner</p> <p>Address of the NFT item owner.</p> <p>Ownership</p> <p>Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format <code>${contract}:${tokenId}:${owner}</code>.</p>","title":"O"},{"location":"getting-started/glossary/#p","text":"<p>Payouts</p> <p>Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users.</p> <p>Platform</p> <p>The platform where the order was created.</p>","title":"P"},{"location":"getting-started/glossary/#r","text":"<p>Royalties</p> <p>Fees that are usually paid to the creator on every sale.</p>","title":"R"},{"location":"getting-started/glossary/#s","text":"<p>Salt</p> <p>Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash.</p> <p>Smart Contract</p> <p>The programs stored on a blockchain that run when predetermined conditions are met.</p> <p>Supply</p> <p>Total number of tokens minted or to be minted.</p>","title":"S"},{"location":"getting-started/glossary/#t","text":"<p>Take</p> <p>Take the side of the order, what order creator wants to get in return for <code>make</code> side.</p> <p>Token ID</p> <p>Token identifier.</p>","title":"T"},{"location":"getting-started/quick-start/","text":"<p>It's a Quick Start Guide for starting using Multichain SDK.</p> <p>We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section.</p>","title":"Quick Start"},{"location":"getting-started/quick-start/#installation","text":"<pre><code>npm install -D @rarible/sdk\nnpm install web3\n</code></pre> <p>or using yarn</p> <pre><code>yarn add @rarible/sdk -D\nyarn add web3\n</code></pre>","title":"Installation"},{"location":"getting-started/quick-start/#usage-sdk","text":"<p>Create a project with the JS framework of your choice (we'll be using NextJS here).</p> <p>To properly set up the Rarible SDK, we need to follow standard Web3 practices.</p> <ol> <li>Grab the Ethereum object out of the global window object.</li> <li>Use it to create a new instance of Web3.</li> <li>Create a new instance of EthereumWallet class.</li> <li>Create Rarible SDK with a new instance of ethereumWallet, created in the previous step.</li> </ol> <p>In code, it looks like that (using TypeScript):</p> <pre><code>// Imports\nimport Web3 from \"web3\"\nimport { createRaribleSdk } from \"@rarible/sdk\"\nimport { EthereumWallet } from \"@rarible/sdk-wallet\"\nimport { Blockchain } from \"@rarible/api-client\"\nimport { Web3Ethereum } from \"@rarible/web3-ethereum\"\n\n// Code\nconst { ethereum } = window as any\nconst web3 = new Web3(provider)\nconst web3Ethereum = new Web3Ethereum({ web3 })\nconst ethWallet = new EthereumWallet(web3Ethereum)\nconst raribleSdk = createRaribleSdk(ethWallet, \"staging\")\n</code></pre> <p>In <code>createRaribleSdk</code>, we have several environment parameters:</p> <ul> <li><code>prod</code> (mainnet)</li> <li><code>dev</code> (ropsten)</li> <li><code>staging</code> (rinkeby)</li> <li><code>e2e</code> (you probably won't use this)</li> </ul> <p>The difference between them is the chain Id and the Rarible API endpoint.</p> <p>And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected.</p> <p>See Rarible Protocol Software Development Kit repo on GitHub for more information about using SDK.</p>","title":"Usage SDK"},{"location":"getting-started/quick-start/#usage-sdk-on-the-server-backend","text":"<p>The SDK was designed for use on the frontend side. To use the SDK on the server side (backend):</p> <ol> <li> <p>Install packages:</p> <pre><code>yarn add tslib@2.3.1\nyarn add form-data\nyarn add node-fetch\n</code></pre> </li> <li> <p>Add dependencies:</p> <pre><code>global.FormData = require(\"form-data\")\nglobal.window = {\n  fetch: require(\"node-fetch\"),\n  dispatchEvent: () =&gt; {\n  },\n}\nglobal.CustomEvent = function CustomEvent() {\n  return\n}\n</code></pre> </li> </ol>","title":"Usage SDK on the server (backend)"},{"location":"getting-started/quick-start/#preprocessing-metadata","text":"<p>Let's use the preprocess function to prepare metadata for different blockchains.</p> <pre><code>const blockchain = Blockchain.ETHEREUM;\nconst metadata: CommonTokenMetadata = {\n  name: \"Hey\",\n  description: undefined,\n  image: undefined,\n  animationUrl: undefined,\n  externalUrl: undefined,\n  attributes: [],\n};\nconst request: PreprocessMetaRequest = {\n  blockchain,\n  ...metadata,\n};\nconst response = sdk.nft.preprocessMeta(request);\n</code></pre> <p>See Example of uploading &amp; using Metadata with IPFS for more information about IPFS.</p>","title":"Preprocessing Metadata"},{"location":"getting-started/quick-start/#create-collection","text":"<p>There are several collection types:</p> <ul> <li>collection \u2014 can mint anyone</li> <li>user collection \u2014 can mint only owner, need <code>isUserToken: true</code></li> </ul> <p>You can use any public collection to mint and sell NFTs.</p> <p>If you want to create your collection, you have to use the deploy function in Ethereum blockchain through the Multichain SDK. ERC-1155 and ERC-721 collections look the same.</p> <pre><code>const ethereum = new Web3Ethereum({ web3: web3 }) //user web3 instance\nconst ethereumWallet = new EthereumWallet(ethereum)\nconst sdk = createRaribleSdk(ethereumWallet, \"staging\")\n await sdk.nft.deploy({\n  blockchain: Blockchain.ETHEREUM,\n  asset: {\n   assetType: \"ERC721\",\n   arguments: {\n    name: \"My own NFT collection\",\n    symbol: \"RARI\",\n    baseURI: \"https://ipfs.rarible.com\",\n    contractURI: \"https://ipfs.rarible.com\",\n    isUserToken: false, // public collection\n   },\n  },\n })\n</code></pre>","title":"Create Collection"},{"location":"getting-started/quick-start/#erc-721-nft-lazy-minting-sell","text":"<p>Often users want to list their NFTs on the sale right after creation. For this case, use <code>mintAndSell</code> function, which allows you to do exactly that.</p> <pre><code>const currentWallet = wallet as EthereumWallet;\nconst makerAccount = await currentWallet.ethereum.getFrom();\n// Price in ETH\nconst price: number = 1;\nconst mintRequest: PrepareMintRequest = {\n  collectionId: toContractAddress(\n    \"ETHEREUM:CONTRACT_ADDRESS\"\n  ),\n};\nconst ethCurrency: EthErc20AssetType = {\n  \"@type\": \"ERC20\",\n  contract: toContractAddress(\n    \"ETHEREUM:CONTRACT_ADDRESS\"\n  ),\n};\nconst mintResponse = await sdk.nft.mintAndSell(mintRequest);\nconst response = await mintResponse.submit({\n  uri,\n  supply: 1,\n  lazyMint: true,\n  price,\n  creators: [\n    {\n      account: toUnionAddress(`ETHEREUM:${makerAccount}`),\n      value: 10000,\n    },\n  ],\n  currency: ethCurrency,\n});\n// Response:\n// ItemId\n// OrderId\n</code></pre> <p>See ERC721-NFT Lazy Minting and List NFT on sell for more information.</p>","title":"ERC-721 NFT Lazy Minting &amp; Sell"},{"location":"getting-started/reasons/","text":"<p>Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics.</p> <p>NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem.</p>","title":"Why build on Rarible protocol?"},{"location":"getting-started/reasons/#supply-and-demand-of-the-whole-rarible-ecosystem","text":"<p>Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible.</p>","title":"Supply and demand of the whole Rarible ecosystem"},{"location":"getting-started/reasons/#advanced-and-robust-tech-done-for-you","text":"<p>Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created.</p>","title":"Advanced and robust tech done for you"},{"location":"getting-started/reasons/#monetization","text":"<p>Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.</p>","title":"Monetization"},{"location":"getting-started/reasons/#decentralized-autonomous-organization-dao","text":"<p>Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.</p>","title":"Decentralized autonomous organization (DAO)"},{"location":"overview/protocol-status/","text":"<p>Available in Q2 2022</p>","title":"Protocol Status Page"},{"location":"overview/union/","text":"<p>Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains:</p> <ul> <li>Ethereum</li> <li>Flow</li> <li>Tezos</li> <li>Polygon</li> </ul> <p>The Rarible Protocol is based on the blockchain layer (smart contracts written for every blockchain supported). These smart contracts allow users to mint and exchange tokens.</p> <p>On top of the contracts, we built indexers to index part of the blockchain state. This gives us the possibility to query data about NFTs.</p> <p>Then, SDKs were written to interact with smart contracts.</p> <p>All these components are written for every blockchain supported and are used in Multichain service and Multichain SDK.</p> <p>Applications need to integrate Multichain service and Multichain SDK to be able to interact with all blockchains in the same way.</p>  <p> </p> Protocol architecture","title":"Rarible Protocol"},{"location":"overview/union/#features","text":"<ul> <li>Mint (issue, create) NFTs</li> <li>Trade NFTs (sell, bid, auction)</li> <li>Transfer</li> <li>Burn</li> <li>Query information about NFTs</li> </ul> <p>See more reasons to build on Rarible Protocol.</p>","title":"Features"},{"location":"overview/union/#api-reference","text":"<p>We use different environments for blockchain networks. See actual information on API Reference page.</p>","title":"API Reference"},{"location":"overview/union/#sdk","text":"<p>Rarible Protocol SDK enables applications to easily interact with Rarible protocol: query, issue, trade NFTs on any blockchain supported.</p> <p>See more information on Multichain SDK page.</p>","title":"SDK"},{"location":"polygon/polygon-overview/","text":"","title":"Rarible Protocol Polygon"},{"location":"polygon/polygon-overview/#overview","text":"<p>Polygon is a decentralized Ethereum scaling platform that enables developers to build scalable, user-friendly dApps with low transaction fees without sacrificing security.</p> <p>Main features:</p> <ul> <li>Supports all the existing Ethereum tooling</li> <li>Faster and cheaper transactions</li> <li>High throughput</li> </ul>","title":"Overview"},{"location":"polygon/polygon-overview/#smart-contracts","text":"Smart Contract Mainnet Mumbai     Exchange 0x835131b455778559CFdDd358eA3Fc762728F4E3e 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5   Transfer Proxies 0xd47e14DD9b98411754f722B4c4074e14752Ada7C 0x02e21199D043dab90248f79d6A8d0c36832734B0   ERC-721 Token Factory 0x16911a36a56f828f17632cD4915614Dd5c7a45e0 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d   ERC-1155 Token Factory 0xF46e8e6fA0F048DdD76F8c6982eBD059796298B8 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4    <p>To see more details about the smart contracts as well as their code, check the Protocol Contracts GitHub repo.</p>","title":"Smart Contracts"},{"location":"polygon/polygon-overview/#api-reference","text":"<p>Subject to change</p> <p>The following APIs are used for internal work and can change in future versions.</p>  <p>Use these base URLs to access API on different Ethereum networks:</p>    Base URL Network     https://polygon-api.rarible.org/v0.1 Mainnet   https://polygon-api-staging.rarible.org/v0.1 Mumbai Staging   https://polygon-api-dev.rarible.org/v0.1 Mumbai Dev    <p>Polygon API documentation can be found here:</p> <ul> <li>Mainnet</li> <li>Staging</li> <li>Development</li> </ul>","title":"API Reference"},{"location":"polygon/polygon-overview/#sdk","text":"<p>Polygon is using Ethereum SDK to interact with your application and the Rarible Protocol.</p> <p>Main features:</p> <ul> <li>Create Mint and Lazy Minting ERC-721 and ERC-1155 tokens</li> <li>Create Sell Orders</li> <li>Create and accept Bid</li> <li>Buy tokens</li> <li>Transfer tokens</li> <li>Burn tokens</li> </ul> <p>For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.</p>","title":"SDK"},{"location":"resources/meetings/meeting-doc-15th-of-october/","text":"<p>Meeting document for dev meeting on the 15th of October.</p>","title":"Meeting doc 15th of october"},{"location":"resources/meetings/meeting-doc-15th-of-october/#github","text":"<p>https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered</p> <p>I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed. </p>","title":"Github"},{"location":"resources/meetings/meeting-doc-15th-of-october/#discord","text":"<p>Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. </p> <p>All people listed below have also been invited to participate this dev call.</p> <p><code>alexon#6056</code></p> <p>Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\"</p> <p>Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators.  I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\"</p> <p>Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction)</p> <p><code>inartin#9707</code></p> <p>Quote: \"Is there an API call that will return ALL types of order activities?  Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)?</p> <p>The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \"</p> <p>Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type</p> <p><code>chusla#6031</code></p> <p>Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com?  Etherscan shows it's been burned.  Do these also have to be manually deleted in lazy db?  https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2.  Thank you! trying to come with a plan of action to clear the collection for new mints  If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\"</p> <p>Answer: \"If it was fully burned, it should not appear on .com\" </p> <p>Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner.  The original owner can then put it back in for sale and then it can get purchased again!</p> <p></p> <p>Fyi screen above shows history of an item that was put back on sale AFTER being burned.  I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\"</p> <p>Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135</p> <p>Answer: This looks like a serious bug. Will wix it.</p> <p><code>mynamebrody#5466</code></p> <p>Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\"</p> <p>Answer: This is because prod version was not updated to the latest version. I think everything should be fine now.</p> <p><code>tgb2929#1533</code></p> <p>Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: {        assetClass: \"ERC20\",        contract: contractErc20Address    }\" https://docs.rarible.org/sdk#create-sell-order\"</p> <p>Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\"</p> <p>Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\"</p> <p>Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet?</p> <p><code>lazycaramel#4474</code></p> <p>Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\"</p> <p>Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created.</p> <p><code>Rhabdodon#4653</code></p> <p>Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f </p> <p>I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol.</p> <ol> <li> <p>Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. </p> </li> <li> <p>Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. </p> </li> <li> <p>Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. </p> </li> <li> <p>Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. </p> </li> <li> <p>Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\"</p> </li> </ol> <p>Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures</p> <p><code>agamanin#2389</code></p> <p>Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\"</p> <p>Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source.</p> <p>Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\"</p> <p>Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there.</p> <p><code>Unnatural Space#0655</code></p> <p>Quote: \"is the rarible protocol compatible with polygon network?\"</p> <p>Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. </p> <p>Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28</p> <p><code>chusla#6031</code></p> <p>Quote: \"Hi all question on sdk.  My recent understanding is that the mint function automatically generates the contract token ID.  But how does this work with including token id in external URI in Json metadata?  Don't we need to generate token id before Json/ipfs upload and then mint?  Any thoughts on this much appreciated.  Seems like there may be an order of operations issue here?  I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint.  Would be great to discuss on today's call thanks!\"</p> <p>Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28</p>","title":"Discord"},{"location":"resources/meetings/meeting-doc-22nd-of-october/","text":"<p>Meeting document for dev meeting on the 22nd of October.</p>","title":"Meeting doc 22nd of october"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#github","text":"<p>None. There are two \"unanswered\" questions that on which we're waiting on a reply from the question owner. </p>","title":"Github"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#discord","text":"<p>Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. </p> <p>All people listed below have also been invited to participate this dev call.</p> <p><code>owenmurovec#8687</code></p> <p>Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\",     \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\",     \"status\": 400 }</p> <p>According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type.</p> <p>Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\"</p> <p><code>richexplorer.eth#8225</code></p> <p>Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset </p> <p>But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done</p> <p>data: {     }       code: 'VALIDATION',       message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address',       status: 400</p> <p>Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\"</p> <p><code>fruitybits#4442</code></p> <p>Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"</p>","title":"Discord"},{"location":"resources/meetings/meeting-doc-29th-of-october/","text":"<p>Meeting document for dev meeting on the 29th of October.</p> <p>Github discussions: </p> <p>https://github.com/rarible/protocol/discussions/142 <code>whitespace#2877</code></p> <p>Answer: Eugene to look into it later. Meeting is too short to review there.</p> <p>https://github.com/rarible/protocol/discussions/11 - related to spam NFT's being minted to someone's collection</p> <p>Answer: </p> <p>We already have discussed about this. There is now a contract where only the owner can mint.</p> <p>We will have the possibility to deploy private contracts via the SDK, adding the feature is in our backlog. The release can be expected Monday / Tuesday next week (first week of November)</p> <p>Any collection that has already been released won't be able to benefit from this. </p> <p>Github issues: </p> <p>Most important: https://github.com/rarible/protocol/issues/148 <code>owenmurovec#8687</code></p> <p>Answer: We already fixed this in our contract. There is a PR waiting to be merged, will probably be done by Monday / Tuesday next week (first week of November)</p> <p>https://github.com/rarible/protocol/issues/147 <code>Jaacob#1962</code> and <code>Branko#7207</code></p> <p>Answer: Need a TXID / Hash  github issue was updated </p> <p>https://github.com/rarible/protocol/issues/143 <code>tgb29#1533</code></p> <p>Answer: Metamask should say that there is an exception in the transaction, but that isn't shown correctly. We have raised this issue to the metamask team. </p> <p>https://github.com/rarible/protocol-ethereum-sdk/issues/52 from <code>inartin#9707</code></p> <p>Answer: Need to check at another time / Please DM Eugene on TG</p> <p>Discord:</p> <p><code>chusla#6031</code></p> <p>Quote: \"could we get an update on latest browser compatible sdk as well that would be much appreciated if there is any way at all to include that in next week's release for tezos etc that would unblock us thanks!\"</p> <p>Answer: We've got a PR open for the browser compatible SDK, we will try to move it to review within the next week. </p> <p><code>mynamebrody#5466</code></p> <p>Quote: \"I think I'm having issues with the encodeOrder endpoint as it wants a signature but that's not required for this call yet so I haven't been including it. But adding the field with an empty value gets past this error, however, I don't think it should be there\"</p> <p>Answer: Will check.</p> <p><code>platocrat#4224</code></p> <p>Quote: \"@Matt a friend just sent me this, which comes from your documentation.  Is this correct? We should just fork Rarible Protocol, deploy the protocol to Polygon, then use those contracts to deploy our ERC1155 contracts?\" Just to clarify, i wish to use Rarible's contracts, which i assume to be on, Polygon to deploy our contracts \ud83d\ude42 </p> <p>Answer: I believe that is correct, to deploy contracts you can fork/clone the repo. What's needed to be done is to put the configuration for Polygon and deploy it to this network. But that's not everything. Rarible Protocol is not only about contracts, is about indexer and sdk as well. We have already deployed our indexer on polygon testnets but with SDK this is a bit harder because we would like to use meta transactions which means we would need to change our SDK to support these meta transactions. These are these main tasks we need to get done in order to use Polygon. We'll try it after we deploy on Tezos and Flow. Might try initial testing next week. Would be better to wait imo. </p> <p><code>idan.angel#8635</code></p> <p>Quote: \"Hi All, I'm looking for a Rarible API that would return the assetType for any NFT listed on the marketplace. In other words, I'm looking for something like:  GET ?itemId=: <p>and I expect to get an answer that would contain a field with ERC721 or ERC1155 or Lazy_mint, something of that sort, so that I can use that value to create a new buy order. I haven't found anything of that sort. For some NFTs there are open orders which hold the assetType, but I'm looking for a standard way that would work on every NFT on Rarible, not just NFTs with open or past orders.</p> <p>Any help would be appreciated.\"</p> <p>Answer: If SDK is used, that's not needed. They just need to get an order and execute field in the SDK and the inverted order will be automatically made. If any further help is needed contact</p> <p><code>owenmurovec#8687</code></p> <p>Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\",     \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\",     \"status\": 400 }</p> <p>According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type.</p> <p>Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\"</p> <p>Answer: creating-a-sell-order in the docs is a bit outdated, we'll fix that. Also. encodeOrder is deprecated, it's better to use SDK. Rarible docs now have a blockchain agnostic structure that isn't tied to Ethereum, there is information on how to use the SDK there.</p> <p><code>richexplorer.eth#8225</code></p> <p>Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset </p> <p>But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done</p> <p>data: {     }       code: 'VALIDATION',       message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address',       status: 400</p> <p>Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\"</p> <p>Answer: Same as the answer above, please use SDK. </p> <p><code>fruitybits#4442</code></p> <p>Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"</p> <p>Answer: Royalties V1 or V2 will do. Any version will be working on Polygon without a problem once we deploy there.</p>","title":"Meeting doc 29th of october"},{"location":"resources/meetings/meeting-doc-5th-of-november/","text":"<p>Meeting document for dev meeting on the 5th of November.</p> <ol> <li>Update on the 12k$ contract upgrade.</li> </ol> <p>When are we going to deploy that fix now that the gas fees seem to have lowered down?</p> <ol> <li>Update on Flow. </li> </ol> <p>Are we still on track to deploy between 8th and the 12nd of November?</p> <ol> <li>Update on the bidding function. </li> </ol> <p>The bid function doesn't seem to be fully supported by the SDK. What is the situation with that? (Question is related to <code>alexon#6056</code>'s question below)</p>","title":"Meeting doc 5th of november"},{"location":"resources/meetings/meeting-doc-5th-of-november/#github","text":"<p>https://github.com/rarible/protocol/issues/140 - &gt; When will the error message / html status be changed?</p> <p>https://github.com/rarible/protocol/issues/133 - &gt; Has this been fixed? If not, what is an ETA for a fix. </p> <p>https://github.com/rarible/protocol/issues/120 - &gt; Have we found a way to implement this?</p> <p>https://github.com/rarible/protocol/issues/152 - &gt; </p> <p>https://github.com/rarible/protocol/issues/151 - &gt; </p> <p>https://github.com/rarible/protocol-ethereum-sdk/issues/52 - &gt;</p>","title":"Github"},{"location":"resources/meetings/meeting-doc-5th-of-november/#discord","text":"<p><code>Nick - Ownerfy#8137</code></p> <p>Quote: \"simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\"</p> <p>Answer: </p> <p><code>Zoomer#5825</code></p> <p>Quote: \"Hi frens. I'm trying to parse Rarible trades on Ethereum. I see here in the exchange contract's events that the events with topic0 as 0x268820db288a211986b26a8fda86b1e0046281b21206936bb0e61c67b5c79ef4 have all useful info in the arguments  But the event with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e does not seem to contain the address of the traded NFT What is the difference between these two events? And is there any simple way for me to get the contract address of the NFT being traded in the transaction with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e? (Here's a link of what I'm looking at https://etherscan.io/address/0x9757F2d2b135150BBeb65308D4a91804107cd8D6#events)\"</p> <p>Answer:</p> <p><code>alexon#6056</code></p> <p>Quote: \"are you guys migrating to a new sdk? Just saw the docs link to a new repo. I ask because I just created a bid with the procotol-ethereum-sdk and I used ETH as the make asset. The issue I'm seeing is that it's not coming back in the bids api from https://api-staging.rarible.com/protocol/v0.1/ethereum/order/bids/byItem. I made a bit through rarible and that one does show up. Actually, I noticed it's just because it's marked as INACTIVE. Is there a reason why it's that way? I know rarible makes you convert eth to weth first to place a bid. But there is no exaplanation on how to do that in the docs. \" </p> <p>Answer:</p> <p><code>rimb05#3257</code></p> <p>Quote: \"When will the 721 lazy minting minimal version be deployed?\"</p> <p>Answer:</p>","title":"Discord"},{"location":"resources/meetings/meeting-doc-8th-of-october/","text":"<p>Meeting document for dev meeting on the 8th of October. </p>","title":"Meeting doc 8th of october"},{"location":"resources/meetings/meeting-doc-8th-of-october/#addresing-the-httpsapi-stagingrariblecom-to-httpsethereum-apiraribleorg-replacement-in-the-docs","text":"<p>There are 4 instances where api-staging is used in the docs.  1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting</p>","title":"Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs."},{"location":"resources/meetings/meeting-doc-8th-of-october/#github","text":"<p>https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered</p> <p>I've realised that discussions that are not in the Q&amp;A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there. </p>","title":"Github"},{"location":"resources/meetings/meeting-doc-8th-of-october/#discord","text":"<ul> <li>All members who have a question listed below have been invited to participate in this call</li> <li>All members will be notified about the answer to their question privately or in #dev-general (discord)</li> <li>Only the past 7 days of unanswered questions are indexed here. </li> </ul> <p><code>Konstantin#3916</code></p> <p>Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\"</p> <p>Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted.</p> <p><code>Rhabdodon#4653</code></p> <p>Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\"</p> <p>\"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires  minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\"</p> <p>\"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\"</p> <p>Answer: Skipped -- </p> <p><code>alexon#6056</code></p> <p>Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\"</p> <p>Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js</p> <p><code>Laviniao#9840</code></p> <p>Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\"</p> <p>\"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\"</p> <p>Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. </p> <p><code>Peter Watts#5307</code></p> <p>Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\"</p> <p>Answer: Add to github issues. </p> <p><code>AzFlin#5259</code></p> <p>Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\"</p> <p>Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task.</p> <p><code>Alexandr Devyatkin#4906</code></p> <p>Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\"</p> <p>Answer: This matter was already discussed between Eugene and Alexandr.</p> <p><code>bold#5220</code></p> <p>Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\"</p> <p>\"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\"</p> <p>Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. </p> <p>Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. </p> <p><code>nullren#4914</code></p> <p>Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\"</p> <p>Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. </p> <p><code>NiFTiChristian#7535</code></p> <p>Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\"</p> <p>Answer: Add to github issues. </p>","title":"Discord"},{"location":"snippets/subject-to-change-api/","text":"<p>Subject to change</p> <p>The following APIs are used for internal work and can change in future versions.</p>","title":"Subject to change api"},{"location":"snippets/usage-sdk-on-server/","text":"","title":"Usage sdk on server"},{"location":"snippets/usage-sdk-on-server/#usage-sdk-on-the-server-backend","text":"<p>The SDK was designed for use on the frontend side. To use the SDK on the server side (backend):</p> <ol> <li> <p>Install packages:</p> <pre><code>yarn add tslib@2.3.1\nyarn add form-data\nyarn add node-fetch\n</code></pre> </li> <li> <p>Add dependencies:</p> <pre><code>global.FormData = require(\"form-data\")\nglobal.window = {\n  fetch: require(\"node-fetch\"),\n  dispatchEvent: () =&gt; {\n  },\n}\nglobal.CustomEvent = function CustomEvent() {\n  return\n}\n</code></pre> </li> </ol>","title":"Usage SDK on the server (backend)"},{"location":"snippets/usage-sdk/","text":"<p>// Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\"</p> <p>// Code const { ethereum } = window as any const web3 = new Web3(provider) const web3Ethereum = new Web3Ethereum({ web3 }) const ethWallet = new EthereumWallet(web3Ethereum) const raribleSdk = createRaribleSdk(ethWallet, \"staging\")</p>","title":"Usage sdk"},{"location":"tezos/tezos-contract-addresses/","text":"<p>Here you can find Rarible Smart Contracts deployed instances across Tezos Mainnet and Hangzhou Net.</p>","title":"Contract Addresses"},{"location":"tezos/tezos-contract-addresses/#mainnet","text":"Name Address     Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS   royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo   transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD   transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi   fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb   exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC","title":"Mainnet"},{"location":"tezos/tezos-contract-addresses/#hangzhou","text":"Name Address     royalties KT1WKRXswxEpTbVg2pGgofzwZCNKjAVcuMgh   transfer_proxy KT1Qypf9A7DHoAeesu5hj8v6iKwHsJb1RUR2   transfer_manager KT1DyDkW16XBuFzpLkXKraD46SAxQDrha5gm   fill KT1FAndThSQsVqYQVPHGSG5sQPk1XZycNBvL   exchange KT1ULGjK8FtaJ9QqCgJVN14B6tY76Ykaz6M8","title":"Hangzhou"},{"location":"tezos/tezos-overview/","text":"","title":"Rarible Protocol Tezos"},{"location":"tezos/tezos-overview/#overview","text":"<p>Tezos has low fees, high performance, and a smaller carbon footprint than proof-of-work blockchains as a proof-of-stake blockchain.</p> <p>Main features:</p> <ul> <li>Creating NFTs on the Tezos blockchain</li> <li>API server similar to the one already available for Ethereum</li> <li>SDK in the same model as Ethereum</li> <li>Using Crawlori to crawl the Tezos blockchain</li> </ul> <p>Support for the Tezos was built by Tezos team:</p> <ul> <li>Backend and SDK were built by Functori</li> <li>Edukera and Nomadic Labs managed the smart contracts</li> </ul> <p>Source code is available here.</p> <p>Tezos API and SDK documentation can be found here.</p>","title":"Overview"},{"location":"tezos/tezos-overview/#smart-contracts","text":"<p>Tezos Exchange smart contracts it's a port of the Rarible ExchangeV2 contract.</p>  <p> </p> Process flow between contracts  <p>To see more details about the smart contracts as well as their code, check the Exchange Contracts and NFT Contracts on the GitLab repo.</p>","title":"Smart Contracts"},{"location":"tezos/tezos-overview/#api-reference","text":"<p>Subject to change</p> <p>The following APIs are used for internal work and can change in future versions.</p>  <p>Use these base URL to access API on the Tezos network:</p>    Base URL Network Net     https://tezos-api.rarible.org/v0.1 Tezos Mainnet   https://tezos-hangzhou-api.rarible.org/v0.1 Tezos Hangzhou    <p>Tezos API documentation can be found here.</p>","title":"API Reference"},{"location":"tezos/tezos-overview/#sdk","text":"<p>SDK in the same model as Ethereum. It will allow interacting \"programmatically\" with the smart contract and the API server.</p> <p>Tezos SDK documentation can be found here.</p> <p>For more information on using the Rarible Protocol Tezos SDK, see the Tezos SDK and Tezos SDK repo.</p>","title":"SDK"},{"location":"tezos/tezos-sdk/","text":"<p>Tezos SDK enables applications to interact with Protocol easily in the Tezos blockchain. It was built by Functori.</p> <p>SDK documentation can be found here</p>","title":"Tezos SDK"},{"location":"tezos/tezos-sdk/#installation","text":"<pre><code>yarn\nyarn build-all\n</code></pre>","title":"Installation"},{"location":"tezos/tezos-sdk/#usage","text":"","title":"Usage"},{"location":"tezos/tezos-sdk/#configure","text":"<pre><code>const config = {\n  exchange: string; // Exchange address\n  transfer_proxy: string; // Transfer Proxy address\n  fees: BigNumber; // Fees value\n  nft_public: string; // ERC-721 NFT token analog \n  mt_public: string; // ERC-1155 NFT token analog \n  api: string; // API address\n  api_permit: string; // API permit address\n  permit_whitelist: string[]; // Permit whitelist\n  wrapper: string; // Wrapped XTZ token address\n}\n</code></pre> <p>In code, it looks like that (using TypeScript):</p> <pre><code>const config = {\n  exchange: \"KT1ULGjK8FtaJ9QqCgJVN14B6tY76Ykaz6M8\",\n  transfer_proxy: \"KT1Qypf9A7DHoAeesu5hj8v6iKwHsJb1RUR2\",\n  fees: new BigNumber(0),\n  nft_public: \"\",\n  mt_public: \"\",\n  api: \"https://tezos-hangzhou-api.rarible.org/v0.1\",\n  api_permit: \"https://tezos-hangzhou-api.rarible.org/v0.1/\",\n  permit_whitelist: [],\n  wrapper: 'KT1LkKaeLBvTBo6knGeN5RsEunERCaqVcLr9',\n}\n\nconst tezos = in_memory_provider(\n  'edsk...',\n  'https://tezos-hangzhou-node.rarible.org')\nconst provider = {\n  tezos: tezos,\n  config\n}\n</code></pre>","title":"Configure"},{"location":"tezos/tezos-sdk/#deploy","text":"<pre><code>const op = await deploy_nft_public(\n  provider,\n  await provider.tezos.address()\n  )\nawait op.confirmation()\n</code></pre>","title":"Deploy"},{"location":"tezos/tezos-sdk/#minting","text":"<pre><code>const result = await mint(\n  provider: Provider,\n  contract: string,\n  royalties : { [key: string]: BigNumber },\n  supply?: BigNumber,\n  token_id?: BigNumber,\n  metadata?: { [key: string]: string },\n  owner?: string,\n)\n</code></pre>","title":"Minting"},{"location":"tezos/tezos-sdk/#burn","text":"<pre><code>const arg = await burn(\n  provider: Provider,\n  asset_type: ExtendedAssetType,\n  amount?: BigNumber\n)\n</code></pre>","title":"Burn"},{"location":"tezos/tezos-sdk/#transfer","text":"<pre><code>const arg = await transfer(\n  provider: Provider,\n  asset_type: ExtendedAssetType,\n  to: string,\n  amount?: BigNumber\n)\n</code></pre>","title":"Transfer"},{"location":"tezos/tezos-sdk/#sell","text":"<pre><code>const sellOp = await sell(\n  provider_seller,\n  {\n    maker: string,\n    maker_edpk: string,\n    make_asset_type: ExtendedAssetType\n    amount: BigNumber\n    take_asset_type: XTZAssetType | FTAssetType\n    price: BigNumber\n    payouts: Array&lt;Part&gt;\n    origin_fees: Array&lt;Part&gt;\n  }\n)\n</code></pre>","title":"Sell"},{"location":"tezos/tezos-sdk/#bid","text":"<pre><code>const bid = await bid(\n  provider: Provider,\n  {\n    maker: string\n    maker_edpk: string\n    make_asset_type: XTZAssetType | FTAssetType\n    amount: BigNumber\n    take_asset_type: ExtendedAssetType\n    price: BigNumber\n    payouts: Array&lt;Part&gt;\n    origin_fees: Array&lt;Part&gt;\n  }\n)\n</code></pre>","title":"Bid"},{"location":"union-sdk/nft/","text":"<p>Transfer, minting, and burning are the primary operations we can invoke on the blockchain. Below you can find a \"how to use it\" description.</p>","title":"Transfer, Mint, Burn"},{"location":"union-sdk/nft/#erc721-nft-lazy-minting","text":"<p>To lazy mint an item following parameters are required:</p> <ul> <li>URI \u2014 address of data on IPFS</li> <li>supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters)</li> <li>lazyMint \u2014 boolean, if we want to mint it lazily or normally</li> <li>creators \u2014 the array of creators, which allows distributing profits from sell in accordance to defined criteria</li> <li>royalties \u2014 the array of royalties, which allows taking a defined amount of any consecutive sell</li> </ul>  <p>Whenever you see the need for Multichain / Contract address, you can create it as follows:</p> <ol> <li>Blockchain Name</li> <li>Hex Address</li> </ol> <p>Example:</p> <p><code>BlockchainName:HexAddress</code> = <code>ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05</code></p>  <pre><code>// Examplary values of URI and supply\nconst [uri, setUri] = useState&lt;string&gt;(\n  \"ipfs:/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\"\n);\nconst [supply, setSupply] = useState&lt;number&gt;(1);\n\nconst currentWallet = wallet as EthereumWallet;\nconst makerAccount = await currentWallet.ethereum.getFrom();\n\n// 1. Create PrepareMintRequest\n// Collection ids are the address of Rarible Smart Contracts instance\n// You can find them here:\n// https://docs.rarible.org/ethereum/contract-addresses/\n\nconst mintRequest: PrepareMintRequest = {\n  // Using Rarible API, tokenId would also be needed, but SDK takes care for that\n  collectionId: toContractAddress(\n    \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\"\n  ),\n};\n\n// 2. Get Mint Response\n// From mintResponse you can extract additional info e.g. is supply &gt; 1 enabled\nconst mintResponse = await sdk.nft.mint(mintRequest);\n\n// If you want to divide profits here, you can add more than one creator object\n// Combined value amount has to be 10000, which equals to 100 %, same with royalties\nconst creators = [\n  {\n    account: `ETHEREUM:${makerAccount}`,\n    value: 10000,\n  },\n];\n\nconst royalties = [];\n\n// 3. Submit Mint Response\nconst submitResponse = await mintResponse.submit({\n  uri,\n  supply,\n  lazyMint: true, // Lazy Mint is not always available, you can check it in mint response created in step 2\n  creators,\n  royalties,\n});\n\n// Example of successful response\n// itemId: \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\"\n// type: \"off-chain\"\n</code></pre>","title":"ERC721-NFT Lazy Minting"},{"location":"union-sdk/nft/#erc721-nft-lazy-mint-sell","text":"<p>Often you want to list your nft on the sale right after creation. If it's the case for you, you can also use the <code>mintAndSell</code> function, which allows you to do exactly that.</p> <pre><code>// We can get user account in that way, or just extract it from accounts\n// which we saved with Metamask\nconst currentWallet = wallet as EthereumWallet;\nconst makerAccount = await currentWallet.ethereum.getFrom();\n\n// Price in ETH\nconst price: number = 1;\n\nconst mintRequest: PrepareMintRequest = {\n  collectionId: toContractAddress(\n    \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\"\n  ),\n};\n\nconst ethCurrency: EthErc20AssetType = {\n  \"@type\": \"ERC20\",\n  contract: toContractAddress(\n    \"ETHEREUM:0xc778417e063141139fce010982780140aa0cd5ab\"\n  ),\n};\n\nconst mintResponse = await sdk.nft.mintAndSell(mintRequest);\n\nconst response = await mintResponse.submit({\n  uri,\n  supply: 1,\n  lazyMint: true,\n  price,\n  creators: [\n    {\n      account: toMultichianAddress(`ETHEREUM:${makerAccount}`),\n      value: 10000,\n    },\n  ],\n  currency: ethCurrency,\n});\n\n// Response:\n// ItemId\n// OrderId\n</code></pre>","title":"ERC721-NFT Lazy Mint &amp; Sell"},{"location":"union-sdk/nft/#transfer-nft-token","text":"<p>If we want to transfer NFT Token from one wallet address to another, it is simple. Of course, if you want to submit a transfer transaction, you have to be the owner of an NFT.</p> <p>You will need:</p> <ul> <li><code>itemId</code></li> <li><code>transferRequest: PrepareTransferRequest</code></li> </ul> <pre><code>const itemId =\n  \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\";\n\nconst transferRequest: PrepareTransferRequest = {\n  itemId: toItemId(itemId),\n};\n\nconst transferResponse = await sdk.nft.transfer(transferRequest);\n\nconst response = await transferResponse.submit({\n  to: toMultichianAddress(\"ETHEREUM:0x79Ea2d536b5b7144A3EabdC6A7E43130199291c0\"),\n});\n</code></pre>","title":"Transfer NFT Token"},{"location":"union-sdk/nft/#burning-tokens","text":"<p>Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that.</p> <p>Using SDK, you can do that as follows:</p> <pre><code>const itemId =\n  \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\";\n\nconst burnRequest: PrepareBurnRequest = {\n  itemId: toItemId(itemId),\n};\n\nconst burnResponse = await sdk.nft.burn(burnRequest);\n\nconst response = await burnResponse.submit();\n</code></pre>","title":"Burning tokens"},{"location":"union-sdk/nft/#generate-token-id-request","text":"<p>This is not a mandatory step because while using the mint or <code>mintAndSell</code> function, it's automatically done underneath, but it can be useful while using API.</p> <p>Because of lazy minting specification, Rarible generates token id to store it off-chain until the token is actually minted.</p> <pre><code>const genTokenIdReq: GenerateTokenIdRequest = {\n  collection: toMultichianAddress(\n    \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\"\n  ),\n  minter: toMultichianAddress(\"ETHEREUM:0x79Ea2d536b5b7144A3EabdC6A7E43130199291c0\"),\n};\n\nconst tokenIdResponse = await sdk.nft.generateTokenId(genTokenIdReq);\n</code></pre>","title":"Generate Token ID Request"},{"location":"union-sdk/nft/#preprocessing-metadata","text":"<p>We use preprocessing to prepare metadata for different blockchains (eth, flow, tezos, etc.).</p> <pre><code>const blockchain = Blockchain.ETHEREUM;\nconst metadata: CommonTokenMetadata = {\n  name: \"Hey\",\n  description: undefined,\n  image: undefined,\n  animationUrl: undefined,\n  externalUrl: undefined,\n  attributes: [],\n};\n\nconst request: PreprocessMetaRequest = {\n  blockchain,\n  ...metadata,\n};\n\nconst response = sdk.nft.preprocessMeta(request);\n</code></pre> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>","title":"Preprocessing Metadata"},{"location":"union-sdk/order/","text":"<p>When you have your NFT created, there is a high chance that you will want to sell it. Or try at least. The same way somebody may like your NFT, which is currently not for sale and create a bid for that. In this chapter, you can find cookbooks for all of that functionality.</p>","title":"Sell, Fill, Bid"},{"location":"union-sdk/order/#list-nft-on-sell","text":"<p>To list your NFT on sell, you'll need a token address, the one you get back from</p> <pre><code>await mintResponse.submit();\n</code></pre> <p>If you want to create a sell order immediately after lazy minting your token, you can use the <code>mintAndSell</code> function.</p> <p>It's pretty straightforward. All we need is:</p> <ul> <li><code>tokenMultichainAddress:</code> \u2014 string in <code>BLOCKCHAIN:CONTRACT_ADDRESS:TOKEN_ID</code> format, see code for example</li> <li><code>price: number</code> \u2014 price in ETH for which we want to list the token (disclaimer: it's not in wei, it's in ETH, so 0.5 equals 0.5 ETH)</li> <li><code>amount: number</code> \u2014 quantity of NFT we want to list. In case of ERC721 it's 1</li> <li><code>currency</code> \u2014 type of currency: <code>FlowAssetTypeNft | TezosXTZAssetType | EthErc20AssetType</code> etc. you can find all supported currencies <code>@rarible/api-client/build/models/AssetType</code> in node modules</li> </ul> <pre><code>// 1. Examplary values\nconst tokenMultichainAddress: string =\n  \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\";\nconst ethCurrency: EthEthereumAssetType = {\n  \"@type\": \"ETH\",\n};\nconst price: number = 1;\nconst amount: number = 1;\n\n// 2. Create PreapreOrderRequest type object and pass it to sdk.order.sell\nconst orderRequest: PrepareOrderRequest = {\n  itemId: toItemId(tokenMultichainAddress),\n};\n\n// You can extract info about properties from orderResponse e.g.\n// 1. Base fee\n// 2. Max Amount\n// etc.\nconst orderResponse = await sdk.order.sell(orderRequest);\n\n// 3. Submit the transaction -&gt; it will pop up the metamask asking you to sign a transaction\nconst response = await orderResponse.submit({\n  price,\n  amount,\n  currency: ethCurrency,\n});\n// We get order id from the response. It can be useful when we want to update sell order\n</code></pre>","title":"List NFT on sell"},{"location":"union-sdk/order/#update-listed-token-price","text":"<p>To update the listed token price, you need a sell order id.</p> <p>Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one.</p> <pre><code>const price: number = 0.8;\nconst ethCurrency: EthEthereumAssetType = {\n  \"@type\": \"ETH\",\n};\n\nconst orderId =\n  \"ETHEREUM:0x6e794fd04bcf21ee7f347874aefdf36ec1a7b73b5694760b367a7644765a6368\";\n\nconst updateOrderRequest: PrepareOrderUpdateRequest = {\n  orderId: toOrderId(orderId),\n};\n\nconst updateResponse = await sdk.order.sellUpdate(updateOrderRequest);\n\nconst response = await updateResponse.submit({\n  price,\n});\n</code></pre>","title":"Update listed token price"},{"location":"union-sdk/order/#fill-sell-order","text":"<p>Filling a sell order can be compared to paying for an object in a physical store. The sell order is the object being displayed, and filling would represent taking it to the cash register and paying for it.</p> <p>In order to fill up a sell order, the only required data is orderId.</p> <pre><code>const orderId: string = \"ETHEREUM:0x6e794fd04bcf21ee7f347874aefdf36ec1a7b73b5694760b367a7644765a6368\";\n\nconst fillRequest: PrepareFillRequest = {\n  orderId: toOrderId(orderId);\n};\n\nconst fillResponse = await sdk.order.fill(fillRequest);\n\nconst response = await fillResponse.submit({\n  amount: 1 // Number of NFTs to buy\n})\n</code></pre>","title":"Fill sell order"},{"location":"union-sdk/order/#create-a-bid","text":"<p>If filling a sell order can be compared with taking something to the cash register and paying for it, bidding can be compared to seeing something you want, going up to the owner, and saying, \"Hey, I want that, here's my offer.\"</p> <p>In practice, it works in the same way. You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not.</p> <p>You will need:</p> <ul> <li><code>tokenMultichainAddress</code></li> <li><code>currency</code> \u2014 type of currency: <code>FlowAssetTypeNft | TezosXTZAssetType | EthErc20AssetType</code> etc. you can find all supported currencies <code>@rarible/api-client/build/models/AssetType</code> in node modules</li> <li><code>price</code></li> <li><code>amount</code></li> </ul>  <p>The contract in ethCurrency is NOT an ERC721 address which you can find here.</p> <p>It's a WETH address. For different chains, they are as follow:</p> <ul> <li>Mainnet: 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2</li> <li>Rinkeby / Ropsten: 0xc778417e063141139fce010982780140aa0cd5ab</li> </ul>  <pre><code>const tokenMultichainAddress =\n  \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\";\nconst currency: EthErc20AssetType = {\n  \"@type\": \"ERC20\",\n  contract: toContractAddress(\n    // WETH address on Rinkeby/Ropsten testnets\n    \"ETHEREUM:0xc778417e063141139fce010982780140aa0cd5ab\"\n  ),\n};\n\nconst price: number = 1;\nconst amount: number = 1;\n\nconst orderRequest: PrepareOrderRequest = {\n  itemId: toItemId(tokenMultichainAddress),\n};\n\nconst bidResponse = await sdk.order.bid(orderRequest);\n\nconst response = await bidResponse.submit({\n  amount,\n  price,\n  currency,\n});\n</code></pre>","title":"Create a bid"},{"location":"union-sdk/order/#update-a-bid","text":"<p>Similarly to updating a sell order, there is also a possibility to update a bid.  It can be only higher than the original bid order price.</p> <p>You will need:</p> <ul> <li><code>bidOrderId</code> \u2014 you can obtain it from <code>bidResponse.submit</code></li> <li><code>price</code></li> <li><code>updateBidRequest: PrepareOrderUpdateRequest</code></li> </ul> <pre><code>const bidOrderId =\n  \"ETHEREUM:0x27b554bdf22fe72e89f113e9523e8d8a75fb4477d455e100dc2bb132e7f51682\";\nconst price: number = 2;\n\nconst updateBidRequest: PrepareOrderUpdateRequest = {\n  orderId: toOrderId(bidOrderId),\n};\n\nconst updateResponse = await sdk.order.bidUpdate(updateBidRequest);\n\nconst response = await updateResponse.submit({\n  price,\n});\n</code></pre>","title":"Update a bid"},{"location":"union-sdk/order/#cancel-a-bid","text":"<p>In order to cancel a bid, you need an <code>orderId</code>.</p> <pre><code>const bidOrderId =\n  \"ETHEREUM:0x27b554bdf22fe72e89f113e9523e8d8a75fb4477d455e100dc2bb132e7f51682\";\n\nconst cancelOrderRequest: CancelOrderRequest = {\n  orderId: toOrderId(bidOrderId),\n};\n\nconst cancelResponse = await sdk.order.cancel(cancelOrderRequest);\n</code></pre> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>","title":"Cancel a bid"},{"location":"use-cases/bubblesdk/","text":"<p>This plugin has been developed by EzCode.</p> <p>You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io</p> <p>You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io.</p> <p>Link to the plugin</p> <p>Link to documentation</p> <p>Examples on using the plugin</p> <p><code>All examples are open source, you can see how it works from the inside.</code></p>","title":"Rarible SDK No-Code plugin"},{"location":"use-cases/bubblesdk/#api-supported-features","text":"<ul> <li>Get Item Metadata</li> <li>Get Item Data</li> <li>Get Orders By Wallet</li> <li>Get Order By Hash</li> <li>Get NFT Ownership</li> <li>Get NFT Order Activities</li> <li>Get Order Activities By Item</li> <li>Get All NFT Items By Owner, Creator, Collection</li> </ul>","title":"API supported features:"},{"location":"use-cases/bubblesdk/#sdk-supported-features","text":"<ul> <li>ERC721 and ERC1155 supported</li> <li>Mint</li> <li>Lazy Mint (Buyer pays the fee)</li> <li>Custom Royalties</li> <li>Custom Origin Fees</li> <li>Create Order (Sell, Bid)</li> <li>Buy item</li> <li>Accept Bid</li> <li>Transfer an NFT to other wallet</li> <li>Cancel Order</li> <li>Burn</li> </ul> <p>For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here. </p>","title":"SDK supported features:"},{"location":"use-cases/bubblesdk/#how-to-use","text":"<p>Instructions</p> <ol> <li> <p>Place the element Rarible SDK on the page</p> </li> <li> <p>Make sure it is visible (not in a popup or a hidden group)</p> </li> <li> <p>Select the network in the plugin element field \"Environment\"</p> </li> </ol> <p>Ready to go?</p> <p>We are working on documentation and more demo pages.</p> <p>NFT Marketplaces being built with this plugin:  - one2all</p>","title":"How to use:"},{"location":"use-cases/coconft/","text":"<p>TLDR:</p> <p>cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins.</p> <p>cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer.</p> <p>cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs.</p> <p>How cocoNFT would have changed things knowing what they know now:</p>  <p>On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process.</p>  <p>In regards to the database side cocoNFT advises understanding how you structure your database.</p> <p>Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs.</p> <ol> <li>Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar)</li> <li>Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens</li> <li> <p>Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations</p>  Note <p>Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both.</p>  </li> <li> <p>Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address.</p> </li> <li>Test some functions like <code>name()</code> or <code>symbol()</code> in your terminal to ensure it's working</li> <li>Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder</li> </ol> <p>API and/or SDK is in the works for cocoNFT.</p>","title":"cocoNFT"},{"location":"use-cases/mintgate/","text":"<p>TLDR: </p> <p>MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers.</p> <p>The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer</p>  <p>We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs.</p>  <p>How MintGate would have changed things knowing what they know now:</p> <p>One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. </p> <p>Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable.  </p> <p>Step by step instructions for how MintGate started building on Rarible protocol:</p> <p>Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs.</p> <ol> <li>Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar)</li> <li>Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens</li> <li> <p>Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations</p>  Note <p>Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both.</p>  </li> <li> <p>Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. </p> </li> <li>Test some functions like <code>name()</code> or <code>symbol()</code> in your terminal to ensure it's working</li> <li>Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder</li> </ol> <p>APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs</p>","title":"MintGate"},{"location":"use-cases/moralisplugin/","text":"","title":"Moralis Lazy Mint & Sell plugin"},{"location":"use-cases/moralisplugin/#moralis-rarible-plugin","text":"<p>This plugin has been developed by the Moralis team.</p> <p>For support, open a github issue</p> <p>Link to the plugin</p> <p>Link to documentation</p> <p>This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it.</p>","title":"Moralis Rarible Plugin"},{"location":"use-cases/moralisplugin/#supported-chains","text":"<p>This plugins works with 2 different blockchains:</p> <ul> <li>Ethereum Mainnet (\u2018eth\u2019)</li> <li>Ethereum Rinkeby (\u2018rinkeby\u2019)</li> </ul>","title":"Supported chains"},{"location":"use-cases/moralisplugin/#supported-tokens","text":"<ul> <li>ERC721</li> <li>ERC1155</li> </ul>","title":"Supported tokens"},{"location":"use-cases/moralisplugin/#sdk","text":"<p>Import the Moralis SDK in your project.</p> <pre><code>&lt;script src=\"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://npmcdn.com/moralis@latest/dist/moralis.js\"&gt;&lt;/script&gt;\n</code></pre>","title":"SDK"},{"location":"use-cases/moralisplugin/#lazy-mint","text":"<p>You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token. <pre><code>await Moralis.Plugins.rarible.lazyMint({\n  chain: 'rinkeby',\n  userAddress: '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3',\n  tokenType: 'ERC1155',\n  tokenUri: '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp',\n  supply: 100,\n  royaltiesAmount: 5, // 0.05% royalty. Optional\n})\n</code></pre> You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each. <pre><code>await Moralis.Plugins.rarible.lazyMint({\n  chain: 'rinkeby',\n  userAddress: '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3',\n  tokenType: 'ERC1155',\n  tokenUri: '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp',\n  supply: 100,\n  royaltiesAmount: 5, // 0.05% royalty. Optional\n  list: true, // Only if lazy listing\n  listTokenAmount: 3, // Only if lazy listing\n  listTokenValue: 10 ** 18, // Only if lazy listing\n  listAssetClass: 'ETH', // only if lazy listing  || optional\n})\n</code></pre></p>","title":"Lazy mint"},{"location":"use-cases/moralisplugin/#sell-order","text":"<p>You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each.</p> <pre><code>await Moralis.Plugins.rarible.createSellOrder({\n  chain: 'rinkeby',\n  userAddress: '0xE78dC206875373B351EEF2D182025bb9a64d67B3',\n  makeTokenId: '104734732573670734795292663651146618103387426131809974624560761860320187646009',\n  makeTokenAddress: '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7',\n  makeAssetClass: 'ERC1155',\n  makeValue: '4',\n  takeAssetClass: 'ETH',\n  takeValue: 10 ** 18,\n});\n</code></pre>","title":"Sell order"},{"location":"use-cases/moralisplugin/#erc20","text":"<p>You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters:</p> <p><pre><code>takeAssetClass: 'ERC20',\ntakeTokenAddress: '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea', // DAI\n</code></pre> Example: <pre><code>await Moralis.Plugins.rarible.createSellOrder({\n  chain: 'rinkeby',\n  userAddress: '0xE78dC206875373B351EEF2D182025bb9a64d67B3',\n  makeTokenId: '104734732573670734795292663651146618103387426131809974624560761860320187646009',\n  makeTokenAddress: '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7',\n  makeAssetClass: 'ERC1155',\n  makeValue: '4',\n  takeAssetClass: 'ERC20',\n  takeTokenAddress: '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea', // DAI\n  takeValue: 10 ** 18,\n});\n</code></pre></p>","title":"ERC20"},{"location":"use-cases/picnic/","text":"<p>We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data.</p>","title":"Picnic"},{"location":"use-cases/picnic/#api-calls","text":"<p>The following endpoints can be used:</p> <ul> <li>Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org</li> <li>Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org</li> <li>Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org</li> </ul>","title":"API Calls"},{"location":"use-cases/picnic/#getting-tokens-by-owner","text":"<p>Paginate through owned tokens</p> <pre><code>import axios from 'axios';\n\n/**\n * Get collector's owned tokens.\n * @param {string} owner - owner address (0x...)\n * @param {object} opts - options\n * @param {string} opts.continuation - Rariable continuation ID\n * @param {integer} opts.size - size of tokens to get (default: 100).\n * @return \n */\nconst fetchOwnedTokens = async (owner, opts = {}) =&gt; {\n  const { continuation, size = 100 } = opts;\n\n  try {\n    const result = await axios.get('https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner', {\n      params: { owner, continuation },\n    });\n    const { data } = result;\n\n    // Paginate results\n    let hist = [];\n    if (data.continuation &amp;&amp; data.items.length === size) {\n      hist = await getOwnedTokens(owner, { ...opts, continuation: data.continuation });\n    }\n\n    // Return full history\n    return [...data.items, ...hist];\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n};\n</code></pre> <p>The <code>byOwner</code> endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information.</p> <p>You can use the <code>getItemMetaById</code> Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token.</p> <pre><code>import axios from 'axios';\n\n/**\n * Get token metadata from token id.\n * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001)\n * @return {object}\n */\nconst fetchTokenMetadata = async id =&gt; {\n  const { data } = await axios.get(`https://api.rarible.com/protocol/v0.1/ethereum/nft/items/${id}/meta`);\n  if (!data?.name) {\n    throw new Error('Invalid NFT data', { id, data });\n  }\n  return data;\n};\n</code></pre> <p>If you have question, please reach out. greg@picnic.show / [@gleuch]</p>","title":"Getting Tokens by Owner"},{"location":"use-cases/royalties-on-a-external-collection/","text":"<ol> <li>Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract</li> <li>Active Contract tab. Make sure Write as Proxy is selected near the top.</li> <li> <p>Click Connect to Web3.</p> <p></p> </li> <li> <p>Expand the setRoyaltiesByToken function to set the royalties for the entire collection.</p> <p>You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below.</p> <p>The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties.</p> <p>Below is an example of a tuple which gives the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) 1% royalties on items in the collection.</p> <p>The maximum royalties value is 10000 (100%).</p> <pre><code>[[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]]\n</code></pre> <p>In the screenshot below you can see that on the collection (0x4008c2482357632b06526b492c143f4e73ff1b0d) the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) receives 2.5% (250) Royalties.</p> <p></p> </li> <li> <p>Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction.</p> <p></p> </li> </ol> <p>Now that Royalties have been set up, royalties will be paid out on every sale in that collection.</p> <p>Below is an example of a purchase transaction with annotations on what each fee is for:</p> <p></p>","title":"Setting Up Royalties on an External Collection"}]})